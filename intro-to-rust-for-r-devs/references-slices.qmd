# Ownership

::: callout-tip
## Objective

Understand the how Rust ensures memory safety through the borrow checker and be able to avoid issues by borrowing, using a slice, or cloning.
:::


Rust is notorious for its **borrow checker**. The borrow check is Rust's secret sauce which helps ensure memory safety. At compile time, Rust looks through all of your code to enforce **ownership**. The key is that

> ### variables can be used only once!

If a variable has been used it has been **moved**. There are a number of ways to reuse variables.

## Moves

A move occurs whenever a variable is used by a function or a method.

```rust
fn main() {
    let x = vec![1.0, 2.0, 3.0];
    let y = x; // ‚¨ÖÔ∏è ownership moved
    println!("{:?}", x); // ‚ùå error: value used after move
}
```

Since `x` was moved (used) by assigning it to `y`, the original value cannot be used.


## Cloning

The simplest but least efficient way to reuse a variable is to clone it. This is what R does.

::: callout-tip
Remember: when in doubt, clone it out!
:::

Almost everything in Rust can be cloned by using the `.clone()` method.

::: callout-important

#### Cannot compile

```rust
let x  = v![0.0, 3.14, 10.1, 44.8];

let avg1 = mean(x); // ‚¨ÖÔ∏è x moved here!
let avg2 = mean(x); // ‚ùå compiler error
```
:::

If we first clone `x` before using `mean()` we can use `x` again.

```rust
let x  = v![0.0, 3.14, 10.1, 44.8];

let avg1 = mean(x.clone()); // ‚¨ÖÔ∏è x cloned here!
let avg2 = mean(x); // ‚úÖ compiler happy
```


## Borrowing

While variables may only be used once, they can be **borrowed** infinitely (until they go out of scope). A variable can be used by **reference** when the `&` symbol is placed in front of it‚Äîe.g. `arg: &Vec<f64>`.

```rust
fn main() {
    let x = vec![1.0, 2.0, 3.0];
    let avg = mean(&x); // üëà borrowing `x`
    println!("x is still usable: {:?}", x);
}
```

If you borrow a variable you cannot mutate it or move it.

## Slices

Slices are a special type of borrowing. Slices are a reference to contiguous section of the same type. They're recognized by the syntax `&[T]`.

Slices always have a known length (accessed via `.len()`) and can be used from more than one type.

### Example

Both an array `[f64; N]` and a `Vec<f64>` can be turned into a `&[f64]`

```rust
let x = [0.0, 20.0, 742.3];
let y = vec![1.0, 2.0, 3.0];

let avg_x = mean(&x)
let avg_y = mean(&y);
```

<!--
- A slice is a borrowed section of a collection
- Always a reference: `&[T]`
- Has known length with `.len()`
- Preferred when you don't need the full container

-->

```rust
let values = vec![10.0, 20.0, 30.0];
let avg = mean(&values); // full slice
let avg = mean(&values[0..3]) // the first 3 elements
```

::: callout-tip
We won't cover the `[..]` syntax but you should think it similar to R! It uses a [range](https://doc.rust-lang.org/rust-by-example/flow_control/for.html). A range takes the format of `from..to` where `to` is _uninclusive_. So `0..3` would be indices 0, 1, and 2!
:::

- Slices are lighter-weight than borrowing a full vector
- In general: prefer slices ‚Üí references ‚Üí moves


## Exercise 1

Rewrite the `mean()` function to accept a **reference** to a `Vec<f64>` instead of taking ownership. Then call it with a borrowed vector.

### Solution

<details>
<summary>View solution</summary>

```rust
fn mean(x: &Vec<f64>) -> f64 {
    let mut total = 0.0;
    for xi in x {
        total += xi;
    }
    total / x.len() as f64
}
```

</details>

---


## Exercise 2

- Rewrite `mean()` to accept a slice (`&[f64]`) instead of a `Vec<f64>` reference.
- Try using `mean()` on a subset of values.

### Solution

<details>
<summary>View solution</summary>

```rust
fn mean(x: &[f64]) -> f64 {
    let mut total = 0.0;
    for xi in x {
        total += xi;
    }
    total / x.len() as f64
}
```

</details>
