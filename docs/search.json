[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Rust for R Developers",
    "section": "",
    "text": "Get set up\nBefore we can start, we need to get our house in order. We need to install:",
    "crumbs": [
      "Get set up"
    ]
  },
  {
    "objectID": "index.html#setting-up",
    "href": "index.html#setting-up",
    "title": "Rust for R Developers",
    "section": "",
    "text": "R 4.5\nPositron\nRust\nRust analyzer VS Code extension\nEven Better TOML VS Code extension\n{rextendr}",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Get set up</span>"
    ]
  },
  {
    "objectID": "index.html#install-r",
    "href": "index.html#install-r",
    "title": "Rust for R Developers",
    "section": "Install R",
    "text": "Install R\nPlease install R version 4.5 to ensure that everyone developing has the same experience.\n\n\n\n\n\n\nI recommend using rig to install a new version of R for you.\nInstallation instructions for rig here",
    "crumbs": [
      "Get set up"
    ]
  },
  {
    "objectID": "index.html#install-positron",
    "href": "index.html#install-positron",
    "title": "Rust for R Developers",
    "section": "Install Positron",
    "text": "Install Positron\nDownload the appropriate Positron installer from the downloads page.\nOpen the extensions pane (or press shift + cmd + x).\n\nsearch for rust analyzer and install\nsearch for even better toml and install",
    "crumbs": [
      "Get set up"
    ]
  },
  {
    "objectID": "index.html#install-rust",
    "href": "index.html#install-rust",
    "title": "Rust for R Developers",
    "section": "Install rust",
    "text": "Install rust\nTo install Rust, please use rustup. If you use a system installation via brew, apt, dnf, etc you will likely run into issues. I will be able to help debug these.\nFor installing Rust on Mac / Unix / Linux please run:\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\nWindows\nIf using Windows download the appropriate installer. Then, once your installation is complete, from your command prompt run:\nrustup target add x86_64-pc-windows-gnu\nThis is a compilation target that is required for building extendr packages on Windows.",
    "crumbs": [
      "Get set up"
    ]
  },
  {
    "objectID": "index.html#install-rextendr",
    "href": "index.html#install-rextendr",
    "title": "Rust for R Developers",
    "section": "Install {rextendr}",
    "text": "Install {rextendr}\nWe will be using the rextendr package to build Rust powerd R-packages.\n\n\n\n\n\n\nOther R package dependencies\n\n\n\nWe also will be relying on other packages in the R ecosytem to make developing easier. Please install:\n\ndevtools\nusethis\n\ninstall.packages(c(\"devtools\", \"usethis\"))\n\n\nInstall the package using:\nif (!requireNamespace(\"remotes\")) {\n    install.packages(\"remotes\")\n}\n\nremotes::install_github(\"extendr/rextendr\")\nOnce rextendr is installed, run the below command. You are good to go if:\n\n✅ cargo version is printed (should be 1.80 or greater)\n✅ rustup has a recent version printed\n✅ You have an active default toolchain\n\n\n\n\n\n\n\nIf you’re using windows ensure that x86_64-pc-windows-gnu is your default target. See the above command if it is not.\nR does not support packages compiled with Microsoft Visual C++ (MSVC) so this is required.\n\n\n\n\nrextendr::rust_sitrep()\n\nRust infrastructure sitrep:\n✔ \"rustup\": 1.28.2 (e4f3ad6f8 2025-04-28)\n✔ \"cargo\": 1.85.1 (d73d2caf9 2024-12-31)\nℹ host: aarch64-apple-darwin\nℹ toolchains: stable-aarch64-apple-darwin (active, default),\n  nightly-aarch64-apple-darwin, 1.65.0-aarch64-apple-darwin,\n  1.72.1-aarch64-apple-darwin, 1.74.1-aarch64-apple-darwin,\n  1.75.0-aarch64-apple-darwin, 1.76.0-aarch64-apple-darwin, and\n  1.80.1-aarch64-apple-darwin\n! One of these toolchains should be default: stable-aarch64-apple-darwin\n  (active, default), nightly-aarch64-apple-darwin, 1.65.0-aarch64-apple-darwin,\n  1.72.1-aarch64-apple-darwin, 1.74.1-aarch64-apple-darwin,\n  1.75.0-aarch64-apple-darwin, 1.76.0-aarch64-apple-darwin, and\n  1.80.1-aarch64-apple-darwin\nℹ Run e.g. `rustup default stable-aarch64-apple-darwin (active, default)`",
    "crumbs": [
      "Get set up"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/index.html",
    "href": "intro-to-rust-for-r-devs/index.html",
    "title": "Intro to Rust for R Developers",
    "section": "",
    "text": "Timeline\nobjective go from zero to hero asap writing vectorized code as fast as posisble\nWe’ve got 3 hours to cover a lot of ground!",
    "crumbs": [
      "Intro to Rust for R Developers"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/index.html#timeline",
    "href": "intro-to-rust-for-r-devs/index.html#timeline",
    "title": "Intro to Rust for R Developers",
    "section": "",
    "text": "What is rust\nHello, World!\nPrimitive types, logical/boolean operators, and control flow\nCreating Functions\nArrays & vectors\nFor loops\nMutability\nIterators\nReferences and Slices\nStructs\n\n\n\n\nStart\nDescription",
    "crumbs": [
      "Intro to Rust for R Developers"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/why-rust.html",
    "href": "intro-to-rust-for-r-devs/why-rust.html",
    "title": "1  Why Rust?",
    "section": "",
    "text": "Reasoning\nRust is a programming language that’s fast, safe, and surprisingly friendly to use. Rust turns your code into a standalone program that runs directly on your computer. This makes it much faster and more efficient, similar to languages like C or C++. But where those languages can be hard to use and easy to break, Rust was built to be safer and more helpful.\nRust is especially good at preventing bugs related to memory. There’s no garbage collector in Rust so it is quite memory efficient. Moreover, Rust is designed with the developer in mind. The rust compiler provides error messages that rival—or maybe even surpass—the quality of tidyverse error messaging.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Why Rust?</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/why-rust.html#tldr",
    "href": "intro-to-rust-for-r-devs/why-rust.html#tldr",
    "title": "1  Why Rust?",
    "section": "TL;DR",
    "text": "TL;DR\n\nR is interpreted. Code runs line by line.\nR (and Python) are built on C.\nC is compiled — it builds a binary that runs directly on your machine.\nRust is also compiled, like C, C++, Go, Java, and Fortran.\nThese languages are “close to the metal” — fast, efficient, and powerful.\nRust matches C++ in speed, but with some key advantages:\n\nMemory safety without a garbage collector (unlike Go), thanks to the borrow checker.\nA great developer experience:\n\nHelpful, friendly compiler errors (Tidyverse-level DX).\nModern tooling (cargo, rustdoc, rustfmt, rust-analyzer, etc.).\n\n\nRust is easy to get started with and rewards best practices.\n\nWe won’t go deep into memory safety or concurrency today\n\nRust uses errors as data, unlike R and C++, Rust does not support exceptions",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Why Rust?</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/hello-world.html",
    "href": "intro-to-rust-for-r-devs/hello-world.html",
    "title": "2  Hello, World!",
    "section": "",
    "text": "Crate anatomy\nRust uses a tool called cargo for building, checking, and managing dependencies. This is installed for you when you used rustup to install Rust.\nTo create a new Rust crate, use cargo new name-of-crate. This creates a new directory called name-of-crate. Be sure to cd into that directory.\nTwo types of crates: binary, library.\nBinary crates are standalone applications like command line tools, or things that run once—simiar to a script that you run with Rscript main.R",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Hello, World!</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/hello-world.html#crate-anatomy",
    "href": "intro-to-rust-for-r-devs/hello-world.html#crate-anatomy",
    "title": "2  Hello, World!",
    "section": "",
    "text": "This first workshop we will work only with a binary crate. We will create a library in the second half of the day.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Hello, World!</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/hello-world.html#crate-anatomy-1",
    "href": "intro-to-rust-for-r-devs/hello-world.html#crate-anatomy-1",
    "title": "2  Hello, World!",
    "section": "Crate anatomy",
    "text": "Crate anatomy\nA new crate looks like this:\nintro-to-rust/\n├── Cargo.toml      # Metadata & dependencies (like DESCRIPTION)\n├── Cargo.lock      # Dependency versions (like renv.lock)\n└── src/\n    └── main.rs     # Entry point — like main.R",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Hello, World!</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/hello-world.html#main.rs",
    "href": "intro-to-rust-for-r-devs/hello-world.html#main.rs",
    "title": "2  Hello, World!",
    "section": "main.rs",
    "text": "main.rs\nWhen you create a new rust binary the file src/main.rs is prepopulated with:\n\n\n\n\n\n\nsrc/main.rs\n\n\n\nThe main() function defines what is executed when your binary is run.\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n\nThere are a few things going on in here:\n\nFunctions are declared using the fn keyword\nThe main() function is the entrypoint of the program (and required)\nBlocks of code are delimted using curly braces (like R & C)\nStatements end with ;\nprintln!() is a macro (notice the !) which is used to print to stdout\n\n\n\nWhen a program writes to the console it does so through file connections called standard output (stdout) and standard error (stderr).\nWhen we print a message with print() or message() in R, we print to stdout. When we make a warning or error using stop() or warning() in R, that is writing to stderr.\n\n\n\n\n\n\nVariables can only be defined inside of the main() function.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Hello, World!</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/hello-world.html#println",
    "href": "intro-to-rust-for-r-devs/hello-world.html#println",
    "title": "2  Hello, World!",
    "section": "println!()",
    "text": "println!()\n\nMacros have a !, like println!().\nThink of it like print() in R, but explicit.\nIt supports format strings:\n\n\n\n\n\n\n\nUsing placeholder\nlet name = \"Josiah\";\nprintln!(\"Hello, {}!\", name);\n\n\nDirect interpolation\nlet name = \"Josiah\";\nprintln!(\"Hello, {name}!\");",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Hello, World!</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/hello-world.html#exercise",
    "href": "intro-to-rust-for-r-devs/hello-world.html#exercise",
    "title": "2  Hello, World!",
    "section": "Exercise",
    "text": "Exercise\n\nIn your terminal, create a new rust crate called intro-to-rust\nOpen the new Rust crate’s folder in Positron\nRun the hello world program using cargo run\nCreate a variable called name inside of the main() function with your name\nPrint Hello, {name}! using println!()\n\n\nSolution\n\n\nView solution\n\nIn src/main.rs\nfn main() {\n    let name = \"Josiah\";\n    println!(\"Hello, {name}!\");\n}\nTo run it navigate to your terminal and then run cargo run.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Hello, World!</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/types.html",
    "href": "intro-to-rust-for-r-devs/types.html",
    "title": "3  Basic Types",
    "section": "",
    "text": "Integers\nIn R everything is a vector. A vector is a collection of values. There is no scalar type for a double/ character / integer / logical vector. Those are just length 1 vectors.\nIn Rust, however, scalars are the building blocks of everything. When a collection is needed those are made directly from scalars. You will often hear of these as primitives.\nToday we will only be using a handful of these primitives but it is important to understand what they are—in general.\nIntegers are either signed or unsigned.\nA signed integer can contain a negative value. Whereas an unsigned integer can contain only positive numbers.\nThe letter prefix is the type of primitive. The following number indicates how many bits can be used to store the values. Unsigned integers can contain more possible values because they do not have to support negative numbers.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Types</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/fizz-buzz.html",
    "href": "intro-to-rust-for-r-devs/fizz-buzz.html",
    "title": "4  Control Flow",
    "section": "",
    "text": "Numeric operators",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/fizz-buzz.html#numeric-operators",
    "href": "intro-to-rust-for-r-devs/fizz-buzz.html#numeric-operators",
    "title": "4  Control Flow",
    "section": "",
    "text": "+ addition\n- subtraction\n/ division\n% remainder",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/fizz-buzz.html#logical-operators",
    "href": "intro-to-rust-for-r-devs/fizz-buzz.html#logical-operators",
    "title": "4  Control Flow",
    "section": "Logical Operators:",
    "text": "Logical Operators:\nLogical operators are quite similar to R. The difference is that these operations are not vectorised. Furthermore, in Rust, a logical is called bool for booleans. bools can take on only two values: true or false.\n\n== check equality\n!= check inequality\n! negate a logical value\n&& logical AND comparison\n|| logical OR comparison",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/fizz-buzz.html#control-flow",
    "href": "intro-to-rust-for-r-devs/fizz-buzz.html#control-flow",
    "title": "4  Control Flow",
    "section": "Control flow",
    "text": "Control flow\nRust uses if, else, and else if statements just like R. Where each branch is delimted by curly braces.\n\n\n\n\n\n\nEach branch of the if statement must return the same type. For this portion of the workshop, be sure to terminate each statement with ; inside of the if statement so that nothing (unit type) is returned.\n\n\n\nif x == y {\n  // do something\n} else {\n  // do something else\n}\nThe key difference is that the use of parentheses is not necessary for the conditional statement.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/fizz-buzz.html#exercise",
    "href": "intro-to-rust-for-r-devs/fizz-buzz.html#exercise",
    "title": "4  Control Flow",
    "section": "Exercise",
    "text": "Exercise\nThis exercise you will create the famous FizzBuzz program.\nFor this, create a variable i. The rules are:\n\nwhen i is a multiple of 3, print Fizz\nwhen i is a multiple of 5, print Buzz\nwhen i is a multiple of both 3 and 5, print FizzBuzz\n\n\nSolution\n\n\nView solution\n\nfn main() {\n    // let i = 15; // FizzBuzz\n    // let i = 3; // Fizz\n    // let i = 5; // Buzz\n    let i = 47; // Nothing\n    if (i % 3 == 0) && (i % 5 == 0) {\n        println!(\"FizzBuzz\");\n    } else if i % 3 == 0 {\n        println!(\"Fizz\");\n    } else if i % 5 == 0 {\n        println!(\"Buzz\");\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/collections.html",
    "href": "intro-to-rust-for-r-devs/collections.html",
    "title": "5  Arrays and Vectors",
    "section": "",
    "text": "Arrays\nArrays in Rust are fixed in size and hold values of the same type. Since the size is known ahead of time, it makes them fast but inflexible.\nThe type of an array is specified as [type; length].",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Arrays and Vectors</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/collections.html#arrays",
    "href": "intro-to-rust-for-r-devs/collections.html#arrays",
    "title": "5  Arrays and Vectors",
    "section": "",
    "text": "fn main() {\n    let arr = [10, 20, 30, 40];\n    println!(\"Array: {:?}\", arr);\n}\n\n\n\n\n\n\nThe {:?} syntax is used for a Debug representation of a variable. Using {} is used for Displaying data.\nMore often than not, using {:?} will be your best option.\n\n\n\n\nArrays use square brackets: [1, 2, 3]\nTheir size is known at compile time.\nYou can’t add or remove elements.\nMostly used when performance is critical and size is known.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Arrays and Vectors</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/collections.html#vectors",
    "href": "intro-to-rust-for-r-devs/collections.html#vectors",
    "title": "5  Arrays and Vectors",
    "section": "Vectors",
    "text": "Vectors\nVectors are like growable arrays. They are much more common in everyday Rust code. To create an array with known values, use the vec![] macro. Like an array, they must all be the same type.\nfn main() {\n    let v = vec![1, 2, 3, 4, 5];\n    println!(\"Vector: {:?}\", v);\n}\nThe type of a vector is specified using Vec&lt;T&gt; where T is shorthand for any type.\nAn empty vector can be created using Vec::new() or vec![]. If creating an empty vector, the type must be inferred or made explicit. Vectors also have methods. Two handy ones are .len() and .is_empty() (equivalent of .len() == 0)\n\n\n\n\n\n\nCannot compile\n\n\n\nfn main() {\n    let x = Vec::new();\n    println!(\"x is empty: {}\", x.is_empty();\n}\n\n\nThis cannot compile because the type of x is not known. Rust can infer the type if the vector is used elsewhere where the type is known. To make it compile we must specify the type.\nfn main() {\n    let x: Vec&lt;f64&gt; = Vec::new();\n    println!(\"x is empty: {}\", x.is_empty();\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Arrays and Vectors</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/collections.html#exercise",
    "href": "intro-to-rust-for-r-devs/collections.html#exercise",
    "title": "5  Arrays and Vectors",
    "section": "Exercise",
    "text": "Exercise\n\nCreate an array of 4 integers and print it.\nCreate a vector with 5 numbers and print it using {:?}.\nCompare the length of the array and the vector.\nBonus: create an empty i32 vector.\n\n\nSolution\n\n\nView solution\n\nfn main() {\n    let arr = [1, 2, 3, 4];\n    println!(\"Array: {:?}\", arr);\n\n    let v = vec![10, 20, 30, 40, 50];\n    println!(\"Vector: {:?}\", v);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Arrays and Vectors</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/for-loops.html",
    "href": "intro-to-rust-for-r-devs/for-loops.html",
    "title": "6  for-loops",
    "section": "",
    "text": "for loop syntax\nIn Rust, for loops are the easiest way to go over each item in a vector or array.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>`for`-loops</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/for-loops.html#for-loop-syntax",
    "href": "intro-to-rust-for-r-devs/for-loops.html#for-loop-syntax",
    "title": "6  for-loops",
    "section": "",
    "text": "for value in collection {\n    // do something with value\n}\n\nfn main() {\n    let nums = vec![1, 2, 3];\n    for n in nums {\n        println!(\"n is: {}\", n);\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>`for`-loops</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/for-loops.html#scope",
    "href": "intro-to-rust-for-r-devs/for-loops.html#scope",
    "title": "6  for-loops",
    "section": "Scope",
    "text": "Scope\n\nValues outside of the for loop are accessible inside of it.\nValues created inside of the for loop cannot be accessed outside of it.\n\nExample: outer value used inside loop\nfn main() {\n    let greeting = \"Hi\";\n    let names = vec![\"Alice\", \"Bob\"];\n\n    for name in names {\n        println!(\"{} {}!\", greeting, name);\n    }\n}\nExample: inner value not usable outside loop\n\nThis does not compile!\n\nfn main() {\n    let numbers = vec![1, 2, 3];\n\n    for n in numbers {\n        let doubled = n * 2;\n        println!(\"{} doubled is {}\", n, doubled);\n    }\n\n    // println!(\"Last doubled: {}\", doubled); // ❌ `doubled` doesn't exist here\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>`for`-loops</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/for-loops.html#exercise",
    "href": "intro-to-rust-for-r-devs/for-loops.html#exercise",
    "title": "6  for-loops",
    "section": "Exercise",
    "text": "Exercise\nUsing a vector of integers, write a loop that prints:\n\n“Fizz” if divisible by 3\n“Buzz” if divisible by 5\n“FizzBuzz” if divisible by both\nThe number otherwise\n\nUse this vector: vec![1, 2, 3, 4, 5, 15]\n\nSolution\n\n\nView solution\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5, 15];\n\n    for n in nums {\n        if n % 15 == 0 {\n            println!(\"FizzBuzz\");\n        } else if n % 3 == 0 {\n            println!(\"Fizz\");\n        } else if n % 5 == 0 {\n            println!(\"Buzz\");\n        } else {\n            println!(\"{}\", n);\n        }\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>`for`-loops</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/mutability.html",
    "href": "intro-to-rust-for-r-devs/mutability.html",
    "title": "7  Mutability",
    "section": "",
    "text": "Exercise\nIn Rust, variables are immutable by default. This means once a value is assigned to a variable, it cannot be changed. To make a variable mutable, you must explicitly use the mut keyword.\nBy requiring mut, the compiler ensures that accidental mutations are caught at compile time.\nHere’s an example revisiting our loop from earlier:",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Mutability</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/mutability.html#exercise",
    "href": "intro-to-rust-for-r-devs/mutability.html#exercise",
    "title": "7  Mutability",
    "section": "",
    "text": "Create a vector of 5 or more f64 values (Vec&lt;f64&gt;)\nUse a for loop to calculate the mean of the vector\nPrint the result\n\n\n\n\n\n\n\nWe’ve been working only with integers. To create a float (number with decimals) use 0.0 or specify the type manually e.g. 0f64.\n\n\n\n\nSolution\n\n\nView solution\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0];\n\n    let n = x.len() as f64;\n    let mut total = 0.0;\n\n    for xi in x {\n        total += xi;\n    }\n\n    println!(\"The mean is: {}\", total / n);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Mutability</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/mutable-vectors.html",
    "href": "intro-to-rust-for-r-devs/mutable-vectors.html",
    "title": "9  Mutable Vectors",
    "section": "",
    "text": "Creating empty vectors\nIn Rust, vectors (Vec&lt;T&gt;) are growable arrays. To modify a vector after creating it, the vector itself must be declared as mut.\nYou can create an empty vector and let Rust infer the type based on usage:",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mutable Vectors</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/mutable-vectors.html#exercise",
    "href": "intro-to-rust-for-r-devs/mutable-vectors.html#exercise",
    "title": "9  Mutable Vectors",
    "section": "Exercise",
    "text": "Exercise\n\nCreate an empty vector\nAppend the values 1.0, 2.0, and 3.0 using .push()\nClear the vector to make it empty\nLastly, extend it with another vector e.g. [4.0, 5.0]\nSort the vector\nPrint the final result.\n\n\nSolution\n\n\nView solution\n\nfn main() {\n    let mut x = Vec::new();\n    x.push(1.0);\n    x.push(2.0);\n    x.push(3.0);\n    x.clear();\n    x.extend(vec![4.0, 5.0]);\n    println!(\"{:?}\", x);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mutable Vectors</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/is-odd.html",
    "href": "intro-to-rust-for-r-devs/is-odd.html",
    "title": "10  Functions",
    "section": "",
    "text": "Example\nIdentifying if a number is odd or even isn’t always so easy!\nFirst define a function called is_even() that takes an i32 (integer) and returns a bool.\nWe can use our already defined function inside of another:",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/is-odd.html#example",
    "href": "intro-to-rust-for-r-devs/is-odd.html#example",
    "title": "10  Functions",
    "section": "",
    "text": "is-odd npm\n\n\n\nfn is_even(x: i32) -&gt; bool {\n    x % 2 == 0\n}\n\nfn is_odd(x: i32) -&gt; bool {\n    !is_even(x)\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/is-odd.html#exercise",
    "href": "intro-to-rust-for-r-devs/is-odd.html#exercise",
    "title": "10  Functions",
    "section": "Exercise",
    "text": "Exercise\nCreate a function called mean() that calculates the mean of a Vec&lt;f64&gt;.\n\nIn main(), create a vector x with 5 or more f64 values.\nCall mean(x) and print the result.\n\n\n\n\n\n\n\nUse x.len() to get the length and as f64 to convert it to a float.\n\n\n\n\nSolution\n\n\nView solution\n\nfn mean(x: Vec&lt;f64&gt;) -&gt; f64 {\n    let mut total = 0.0;\n    let n = x.len();\n    for xi in x {\n        total += xi;\n    }\n    total / n as f64\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let result = mean(x);\n    println!(\"Mean is: {}\", result);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/references-slices.html",
    "href": "intro-to-rust-for-r-devs/references-slices.html",
    "title": "10  Ownership",
    "section": "",
    "text": "Moves\nRust enforces ownership at compile time. This ensures memory safety, but it means variables can only be used once—unless they’re borrowed.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/references-slices.html#moves",
    "href": "intro-to-rust-for-r-devs/references-slices.html#moves",
    "title": "10  Ownership",
    "section": "",
    "text": "fn main() {\n    let x = vec![1.0, 2.0, 3.0];\n    let y = x; // 👈 ownership moved\n    println!(\"{:?}\", x); // ❌ error: value used after move\n}\n\nOwnership of x was moved to y\nAfter a move, the original variable (x) can’t be used",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/references-slices.html#borrowing",
    "href": "intro-to-rust-for-r-devs/references-slices.html#borrowing",
    "title": "10  Ownership",
    "section": "Borrowing",
    "text": "Borrowing\nfn main() {\n    let x = vec![1.0, 2.0, 3.0];\n    let avg = mean(&x); // 👈 borrowing `x`\n    println!(\"x is still usable: {:?}\", x);\n}\n\nBorrowing uses & to pass by reference\nYou can borrow a value as many times as you want (immutably)\nYou can’t mutate or move them while borrowed\n\n\n\n\n\n\n\n“When in doubt, clone it out!”\n\n\n\n\n.clone() makes a full copy of a value—useful when you need to keep ownership",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/references-slices.html#exercise-1",
    "href": "intro-to-rust-for-r-devs/references-slices.html#exercise-1",
    "title": "10  Ownership",
    "section": "Exercise 1",
    "text": "Exercise 1\nRewrite the mean() function to accept a reference to a Vec&lt;f64&gt; instead of taking ownership. Then call it with a borrowed vector.\n\nSolution\n\n\nView solution\n\nfn mean(x: &Vec&lt;f64&gt;) -&gt; f64 {\n    let mut total = 0.0;\n    for xi in x {\n        total += xi;\n    }\n    total / x.len() as f64\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/references-slices.html#slices",
    "href": "intro-to-rust-for-r-devs/references-slices.html#slices",
    "title": "10  Ownership",
    "section": "Slices",
    "text": "Slices\n\nA slice is a borrowed section of a collection\nAlways a reference: &[T]\nHas known length with .len()\nPreferred when you don’t need the full container\n\nlet values = vec![10.0, 20.0, 30.0];\nlet avg = mean(&values); // full slice\nlet avg = mean(&values[0..3]) // the first 3 elements\n\n\n\n\n\n\nWe won’t cover the [..] syntax but you should think it similar to R! It uses a range. A range takes the format of from..to where to is uninclusive. So 0..3 would be indices 0, 1, and 2!\n\n\n\n\nSlices are lighter-weight than borrowing a full vector\nIn general: prefer slices → references → moves",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/references-slices.html#exercise-2",
    "href": "intro-to-rust-for-r-devs/references-slices.html#exercise-2",
    "title": "10  Ownership",
    "section": "Exercise 2",
    "text": "Exercise 2\n\nRewrite mean() to accept a slice (&[f64]) instead of a Vec&lt;f64&gt; reference.\nTry using mean() on a subset of values.\n\n\nSolution\n\n\nView solution\n\nfn mean(x: &[f64]) -&gt; f64 {\n    let mut total = 0.0;\n    for xi in x {\n        total += xi;\n    }\n    total / x.len() as f64\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iterators.html",
    "href": "intro-to-rust-for-r-devs/iterators.html",
    "title": "11  Iterators",
    "section": "",
    "text": "Consuming vs. Borrowing\nIterators are values that produce a sequence of items, one at a time. They can be created from collections like vectors, arrays, and ranges.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iterators.html#consuming-vs.-borrowing",
    "href": "intro-to-rust-for-r-devs/iterators.html#consuming-vs.-borrowing",
    "title": "11  Iterators",
    "section": "",
    "text": ".into_iter() consumes the original value, transferring ownership.\n.iter() borrows the collection, producing references to each item.\nA for loop uses .into_iter() under the hood.\n\nfn main() {\n    let nums = vec![3, 6, 9];\n\n    for n in nums.into_iter() {\n        println!(\"Value: {}\", n);\n    }\n    // nums no longer available here ❌\n}\nfn main() {\n    let nums = vec![3, 6, 9];\n\n    for n in nums.iter() {\n        println!(\"Reference to value: {}\", n);\n    }\n    // nums is still usable ✅\n    println!(\"nums: {:?}\", nums);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iterators.html#basic-iterator-methods",
    "href": "intro-to-rust-for-r-devs/iterators.html#basic-iterator-methods",
    "title": "11  Iterators",
    "section": "Basic Iterator Methods",
    "text": "Basic Iterator Methods\nOnce you have an iterator, you can use built-in methods:\n\n.sum() — Add all the values together.\n.min() — Find the smallest value.\n.max() — Find the largest value.\n.enumerate() — Pairs each value with its index.\n\nfn main() {\n    let nums = vec![2, 4, 8];\n    let total: i32 = nums.iter().sum();\n    println!(\"Sum is: {}\", total);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iterators.html#exercise-1",
    "href": "intro-to-rust-for-r-devs/iterators.html#exercise-1",
    "title": "11  Iterators",
    "section": "Exercise 1",
    "text": "Exercise 1\n\nModify the mean() function to calculate the mean using .iter()\nCreate a vector of 5 or more f64 values\nCalculate the mean and print the result\n\n\nSolution\n\n\nView solution\n\nfn mean(x: &[f64]) -&gt; f64 {\n    let total: f64 = x.iter().sum();\n    total / x.len() as f64\n}\n\nfn main() {\n    let nums = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    println!(\"Mean is: {}\", mean(&nums));\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iterators.html#exercise-2",
    "href": "intro-to-rust-for-r-devs/iterators.html#exercise-2",
    "title": "11  Iterators",
    "section": "Exercise 2",
    "text": "Exercise 2\n\nPrint the index and value for each item in a vector for only even values\n\n\nSolution\n\n\nView solution\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5, 6];\n\n    for (i, n) in nums.iter().enumerate() {\n        if n % 2 == 0 {\n            println!(\"Index {i}: {n} is even\");\n        }\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iter-map.html",
    "href": "intro-to-rust-for-r-devs/iter-map.html",
    "title": "12  Mapping over Iterators",
    "section": "",
    "text": "Mapping over iterators",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Mapping over Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iter-map.html#mapping-over-iterators",
    "href": "intro-to-rust-for-r-devs/iter-map.html#mapping-over-iterators",
    "title": "12  Mapping over Iterators",
    "section": "",
    "text": ".map() transforms each item of an iterator by applying a closure (anonymous function)\nClosures are small functions you can define inline, e.g. |x| x + 1\nakin to purrr::map(x, ~ .x + 1) or .purrr::map(x, \\(.x) .x + 1)\nmapping only modifies the iterator\nwe need to collect() the values into another container if we want them\n\n\nExample\nTODO!",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Mapping over Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iter-map.html#collecting-iterators",
    "href": "intro-to-rust-for-r-devs/iter-map.html#collecting-iterators",
    "title": "12  Mapping over Iterators",
    "section": "Collecting iterators",
    "text": "Collecting iterators\n\n.collect() gathers the results of an iterator into a collection (like a vector)\nwe need to specify the type of what we’re collecting into.\nin our case we’re always going to collect into a vector\ntwo ways of specifying\n\nwe can specify the resultant type in the assignment with let x: Vec&lt;i32&gt; but this is not as flexible to changing code\nTurbofish ::&lt;Type&gt;() is used to explicitly specify types when needed\n\nits a bit more awkward at first, but it is more flexible and doesn’t require modification whenever the inner type changes\nadditionall we can use rust’s iference using _\n\n\n\n\nExamples\n\n\n\n\n\n\nExplicit typing\nfn main() {\n    let nums = vec![1, 2, 3];\n\n    // Add 1 to each element\n    let incremented: Vec&lt;_&gt; = nums.iter()\n        .map(|x| x + 1)\n        .collect();\n\n    println!(\"{:?}\", incremented);\n}\n\n\nInference w/ turbofish\nfn main() {\n    let nums = vec![1, 2, 3];\n\n    // Add 1 to each element\n    let incremented = nums.iter()\n        .map(|x| x + 1)\n        .collect::&lt;Vec&lt;_&gt;&gt;();\n\n    println!(\"{:?}\", incremented);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Mapping over Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iter-map.html#exercise-1",
    "href": "intro-to-rust-for-r-devs/iter-map.html#exercise-1",
    "title": "12  Mapping over Iterators",
    "section": "Exercise 1",
    "text": "Exercise 1\nCalculate the variance of a slice of f64 values.\n\\[\n\\text{variance} = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})^2}{n - 1}\n\\]\n\nCreate a function variance() that:\n\nUses .map() to calculate squared differences from the mean\nUses .sum() to add them up\nDivides by n - 1\n\n\n\n\n\n\n\n\n\nUse .powi(2) to square values.\nUse your previously defined mean() function inside variance().\n\n\n\n\n\n\nView hint\n\nfn variance(x: &[f64]) -&gt; f64 {\n    let n = x.len() as f64;\n    let avg = mean(x);\n    let sq_diffs: f64 = x\n        .iter()\n        .map(|xi| ___ )  // squared difference here\n        .__();           // sum method here\n\n    sq_diffs / (n - 1.0)\n}\n\n\nSolution\n\n\nView solution\n\nfn variance(x: &[f64]) -&gt; f64 {\n    let n = x.len() as f64;\n    let avg = mean(x);\n    let sq_diffs: f64 = x\n        .iter()\n        .map(|xi| (xi - avg).powi(2))\n        .sum();\n    sq_diffs / (n - 1.0)\n}\n\nfn main() {\n    let x = vec![2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0];\n    println!(\"Variance is: {:.2}\", variance(&x));\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Mapping over Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iter-map.html#exercise-2",
    "href": "intro-to-rust-for-r-devs/iter-map.html#exercise-2",
    "title": "12  Mapping over Iterators",
    "section": "Exercise 2",
    "text": "Exercise 2\nCreate a function standardize() to perform z-score standardization on a vector of f64.\n\\[\nz_i = \\frac{x_i - \\mu}{\\sigma}\n\\]\n\nUse .iter() and .map() to calculate mean and variance.\nUse .into_iter(), .map(), and .collect() to build the standardized vector.\nReturn a new Vec&lt;f64&gt; of standardized values.\n\n\nSolution\n\n\nView solution\n\nfn standardize(x: &[f64]) -&gt; Vec&lt;f64&gt; {\n    let avg = mean(x);\n    let std_dev = variance(x).sqrt();\n    x.iter().map(|xi| (xi - avg) / std_dev).collect()\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let standardized = standardize(x);\n    println!(\"Standardized: {:?}\", standardized);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Mapping over Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/structs.html",
    "href": "intro-to-rust-for-r-devs/structs.html",
    "title": "14  Defining Struct(ure)s",
    "section": "",
    "text": "Exercise\nYou can define a type as being a collection of other types by using the struct keyword.\nBy convention structs are named using PascalCase, as opposed to fns which are named using snake_case convention.\nAdding behavior to struct is possible through attributes:\nThe Debug trait allows debug printing of the type Point via dbg! or println!(\"{p:?}).\nFields of a struct can be accessed directly, or by reference. If a field is accessed by reference, the struct cannot be moved.\nUnpacking a struct entirely is possible",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Defining Struct(ure)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/structs.html#exercise",
    "href": "intro-to-rust-for-r-devs/structs.html#exercise",
    "title": "14  Defining Struct(ure)s",
    "section": "",
    "text": "Define a struct called Point which has two fields x, and y\nCreate a new Point struct\nDestructure the point",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Defining Struct(ure)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/struct-methods.html",
    "href": "intro-to-rust-for-r-devs/struct-methods.html",
    "title": "14  Struct Methods",
    "section": "",
    "text": "Exercise",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Struct Methods</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/struct-methods.html#exercise",
    "href": "intro-to-rust-for-r-devs/struct-methods.html#exercise",
    "title": "14  Struct Methods",
    "section": "",
    "text": "Define a new method\n\nimpl Struct {\n  fn new(x: f64, y: f64) -&gt; Self {\n    Self { x, y }\n  }\n}\n\ndefine a distance method that calculates the euclidean distance between a point and a reference to another\n\nimpl Point {\n    fn euclidean_distance(&self, destination: &Self) -&gt; f64 {\n        ((self.x - destination.x).powi(2) + (self.y - destination.y).powi(2)).sqrt()\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Struct Methods</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/struct-methods.html#bonus-exercise-2",
    "href": "intro-to-rust-for-r-devs/struct-methods.html#bonus-exercise-2",
    "title": "14  Struct Methods",
    "section": "Bonus: Exercise 2",
    "text": "Bonus: Exercise 2\nHaversine distance is a fast way of calculating distances on a sphere. It is not the most accurate method for all cases, but it’s good enough for many common applications like calculating distances between cities!\nIt is defined by the following equation:\nThe Haversine formula computes the distance between two points on a sphere given their longitudes and latitudes.\n\\[a = \\sin^2\\left(\\frac{\\Delta\\phi}{2}\\right) + \\cos\\phi_1 \\cdot \\cos\\phi_2 \\cdot \\sin^2\\left(\\frac{\\Delta\\lambda}{2}\\right)\\]\n\\[c = 2 \\cdot \\text{atan2}(\\sqrt{a}, \\sqrt{1-a})\\]\n\\[d = R \\cdot c\\]\nWhere:\n\n\\(\\phi\\) represents latitude (in radians) (use .to_radians())\n\\(\\lambda\\) represents longitude (in radians) (use .to_radians())\n\\(R\\) is the Earth’s radius (you can use 6_371_008_7714f64 meters as a mean radius)\n\\(\\Delta\\phi\\) is the difference in latitude between the two points (\\(\\phi_2 - \\phi_1\\))\n\\(\\Delta\\lambda\\) is the difference in longitude between the two points (\\(\\lambda_2 - \\lambda_1\\))\n\\(\\text{atan2}(y, x)\\) is the arctangent of \\(y/x\\), using the signs of both arguments to determine the correct quadrant.\n\nHints for Implementation:\n\nRemember to convert your latitude and longitude values from degrees to radians using the .to_radians() method on f64.\nThe c part of the formula, \\(2 \\cdot \\text{atan2}(\\sqrt{a}, \\sqrt{1-a})\\), can also be implemented using 2 * a.sqrt().asin() in Rust, which is a common simplification when a is within the valid domain for asin.\n\n\nSolution\nimpl Point {\n    fn haversine_distance(&self, destination: &Self) -&gt; f64 {\n        let radius = 6_371_008.7714; // Earth's mean radius in meters\n        let theta1 = self.y.to_radians(); // Latitude of point 1\n        let theta2 = destination.y.to_radians(); // Latitude of point 2\n        let delta_theta = (destination.y - self.y).to_radians(); // Delta Latitude\n        let delta_lambda = (destination.x - self.x).to_radians(); // Delta Longitude\n\n        let a = (delta_theta / 2f64).sin().powi(2)\n            + theta1.cos() * theta2.cos() * (delta_lambda / 2f64).sin().powi(2);\n\n        2f64 * a.sqrt().asin() * radius\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Struct Methods</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/enums.html",
    "href": "intro-to-rust-for-r-devs/enums.html",
    "title": "15  Enum(eration)s",
    "section": "",
    "text": "Enums in R",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Enum(eration)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/enums.html#enums-in-r",
    "href": "intro-to-rust-for-r-devs/enums.html#enums-in-r",
    "title": "15  Enum(eration)s",
    "section": "",
    "text": "for example the R function stats::cor() has the argument method = c(\"pearson\", \"kendall\", \"spearman\").\n\nmethod can only be pearson kendall or spearman otherwise an error happens\n\nthis is an informal way of specifying an enumeration\n\ni’ve wrtten about this in more detail in R which may be interesting for y’all\n\nhttps://josiahparry.com/posts/2023-11-10-enums-in-r/\n\n\n\n\nExample:\nwe can define an enum called Shape\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Enum(eration)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/enums.html#variant-specific-behavior",
    "href": "intro-to-rust-for-r-devs/enums.html#variant-specific-behavior",
    "title": "15  Enum(eration)s",
    "section": "Variant-specific behavior",
    "text": "Variant-specific behavior\n\nchoose a variant by EnumName::Variant This means that Shape can take on only one of those 4 variants\nseems kind of confusing at first, how do you actually use this?\nwe perform pattern matching on the enum and perform some action based on the variant\nuse the keyword match to perform an action based on the value\nwe list each variant and define the action that happens using format Enum::Variant =&gt; action\nnote the “fat arrow”\n\nmatch my_shape {\n    Shape::Triangle =&gt; todo!(),\n    Shape::Rectangle =&gt; todo!(),\n    Shape::Pentagon =&gt; todo!(),\n    Shape::Hexagon =&gt; todo!(),\n}\n\n\n\n\n\n\ntodo!() is a placeholder that can be used to make the compiler happy\n\n\n\n\nExample\n\nwe print the number of vertices for each shape\n\nlet my_shape = Shape::Triangle;\n\nmatch my_shape {\n    Shape::Triangle =&gt; println!(\"A triangle has 3 vertices\"),\n    Shape::Rectangle =&gt; println!(\"A rectangle has 4 vertices\"),\n    Shape::Pentagon =&gt; println!(\"A pentagon has 5 vertices\"),\n    Shape::Hexagon =&gt; println!(\"A hexagon has 6 vertices\"),\n}\n\nsometimes we only want to customize behavior on only a subset of variants\nwe can use a catch all in the match statement _ =&gt; use the underscore to signify “everything else”\n\nmatch my_shape {\n    Shape::Hexagon =&gt; println!(\"Hexagons are the bestagons);\n    _ =&gt; println!(\"Every other polygon is mid\");\n}\nEnums can have methods too just like a struct using impl keyword\nimpl Shape {\n    fn is_bestagon(&self) -&gt; bool {\n        match self {\n            Self::Hexagon =&gt; true,\n            _ =&gt; false\n        }\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Enum(eration)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/enums.html#exercise-1",
    "href": "intro-to-rust-for-r-devs/enums.html#exercise-1",
    "title": "15  Enum(eration)s",
    "section": "Exercise 1",
    "text": "Exercise 1\n\nrecreate the shape enum\ncreate a method called n_vertices() which returns a usize\ncreate two different variants of the Shape enum and print their number of vertices",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Enum(eration)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/enums.html#exercise-2",
    "href": "intro-to-rust-for-r-devs/enums.html#exercise-2",
    "title": "15  Enum(eration)s",
    "section": "Exercise 2",
    "text": "Exercise 2\n\nCreate an enum called Measure with two variants Euclidean and Haversine\nCreate a new method distance() for our point struct that takes 3 arguments and returns an f64\n\na reference to self\na reference to another point\na reference to a Measure enum\n\nWhen the variant is Euclidean use the euclidean_distance() method\nWhen the variant is Haversine use the haversine_distance() method\n\nenum Measure {\n    Euclidean,\n    Haversine,\n}\n\nimpl Point {\n    // Demonstrates using pattern matching an enum\n    fn distance(&self, destination: &Self, measure: &Measure) -&gt; f64 {\n        match measure {\n            Measure::Euclidean =&gt; self.euclidean_distance(destination),\n            Measure::Haversine =&gt; self.haversine_distance(destination),\n        }\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Enum(eration)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/options.html",
    "href": "intro-to-rust-for-r-devs/options.html",
    "title": "16  Some() or None?",
    "section": "",
    "text": "Danger! .unwrap() & .expect()\nOption is defined as:\nwe can match on these. When we have a some value we can use the inner value when we dont we can perform some fallback operation",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>`Some()` or `None`?</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/options.html#danger-.unwrap-.expect",
    "href": "intro-to-rust-for-r-devs/options.html#danger-.unwrap-.expect",
    "title": "16  Some() or None?",
    "section": "",
    "text": "sometimes dealing with options is a headache, particularly when we’re in the early stages of developing\nto get the inner value of an Option&lt;T&gt; without checking we can use .unwrap() or .expect()\nthese both give you the inner value. If the value is not found then the program panics.\n\nthis is very bad\n\nTODO panic screenshot\n.expect() takes a message so that when a panic is encountered the message is more informative.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>`Some()` or `None`?</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/options.html#exercise",
    "href": "intro-to-rust-for-r-devs/options.html#exercise",
    "title": "16  Some() or None?",
    "section": "Exercise",
    "text": "Exercise\n\nmodify the distance() method to take an Option&lt;Measure&gt;\nwhen None use euclidean distance, otherwise use the provided distance measure\n\n\n\nThe exercise does not involve .unwrap() because it’s a bad habbit. Let’s try and form good habbits from the outset if possible.\nimpl Point {\n    fn distance(&self, destination: &Self, measure: Option&lt;&Measure&gt;) -&gt; f64 {\n        match measure {\n            Some(m) =&gt; match m {\n                Measure::Euclidean =&gt; self.euclidean_distance(destination),\n                Measure::Haversine =&gt; self.haversine_distance(destination),\n            },\n            None =&gt; self.euclidean_distance(destination),\n        }\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>`Some()` or `None`?</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/parallelize.html",
    "href": "intro-to-rust-for-r-devs/parallelize.html",
    "title": "18  Parallelizing",
    "section": "",
    "text": "TODO: before this we do combining iterators with .zip() and then go over destructuring into tuples there\n\nthis is a stretch exercise\nBrief intro to rayon\npar_iter()\ninto_par_iter()\nwith_min_len()\nObjective is to calculate the pairwise distances between two vectors of points super fast\nwe want to use .zip() to combine the two vectors\nthis would require using rand to create a vector of random numbers",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Parallelizing</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html",
    "href": "building-rust-based-r-pkgs/index.html",
    "title": "Building Rust based R Packages",
    "section": "",
    "text": "Objective\nIn this workshop we will create a Rust-based R package to perform geohashing using extendr.\nThe first few sections of the workshop may be a litte “lesson” intensive and the latter portion light on it.",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#objective",
    "href": "building-rust-based-r-pkgs/index.html#objective",
    "title": "Building Rust based R Packages",
    "section": "",
    "text": "Learn how to create Rust based R packages using extendr\nBegin to feel comfortable working with data between R & Rust\nCreate an R package to perform geohashing based on the Rust crate called geohash",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#general-overview",
    "href": "building-rust-based-r-pkgs/index.html#general-overview",
    "title": "Building Rust based R Packages",
    "section": "General Overview",
    "text": "General Overview\n\nWhat is FFI\nWhat is extendr\n\nwebR support\n\nR’s C API\nextendr-ffi & extendr-api",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#what-is-a-geohash",
    "href": "building-rust-based-r-pkgs/index.html#what-is-a-geohash",
    "title": "Building Rust based R Packages",
    "section": "What is a geohash?",
    "text": "What is a geohash?\n\nnot everyone is a geospatial nerd but i am\ni have 2 videos on this exact concept\na third video that goes through making this package that inspired this workshop\nSuper quick review of what a geohash is",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#hello-world",
    "href": "building-rust-based-r-pkgs/index.html#hello-world",
    "title": "Building Rust based R Packages",
    "section": "Hello, World!",
    "text": "Hello, World!\n\nCreating a new package usethis::create_package(rstudio = FALSE)\nAdd extendr rextendr::use_extendr()\npackage structure\n\nprevious workshop used a binary crate, we will be building a library crate\n\nrextendr::document()\ndevtools::load_all()\nhello_world()\nreview the contents\n#[extendr] attribute macro\nrprintln!()",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#rextendr-dx",
    "href": "building-rust-based-r-pkgs/index.html#rextendr-dx",
    "title": "Building Rust based R Packages",
    "section": "rextendr DX",
    "text": "rextendr DX\n\nshow the VS Code settings\nrunning cargo check",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#adding-dependencies",
    "href": "building-rust-based-r-pkgs/index.html#adding-dependencies",
    "title": "Building Rust based R Packages",
    "section": "Adding dependencies",
    "text": "Adding dependencies\n\nadd geohash dependency\nrextendr::use_crate()\nimport structs and functions\nimport Coord and encode()",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#a-new-r-function",
    "href": "building-rust-based-r-pkgs/index.html#a-new-r-function",
    "title": "Building Rust based R Packages",
    "section": "A new R function",
    "text": "A new R function\n\ncreate a basic function gh_encode() that takes an x: f64 and a y: f64 value and prints the coordinate\nnext exercise add 3rd argument for length which is [1:12] it’s usize",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#throwing-r-errors",
    "href": "building-rust-based-r-pkgs/index.html#throwing-r-errors",
    "title": "Building Rust based R Packages",
    "section": "Throwing R errors",
    "text": "Throwing R errors\n\nlet’s add validation with throw_r_error()\ncheck that the goehash length is appropriate range\nif not, throw and error",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#calling-rust-from-r",
    "href": "building-rust-based-r-pkgs/index.html#calling-rust-from-r",
    "title": "Building Rust based R Packages",
    "section": "Calling Rust From R",
    "text": "Calling Rust From R\n\nadd #[extendr] macro to the function\n\nthis does magic behind the hood to make it callable from R\n\nthe function must be added to extendr_module! {} for it to be available\nrun rextendr::document() for the new changes to take place\ndevtools::load_all() to make the function available",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#encoding-a-geohash",
    "href": "building-rust-based-r-pkgs/index.html#encoding-a-geohash",
    "title": "Building Rust based R Packages",
    "section": "Encoding a geohash",
    "text": "Encoding a geohash\n\nlets finish up our first function which will geohash a single coordinate by calling encode()\nencode() returns a Result&lt;String&gt;\na Result&lt;&gt; is a special type of Option&lt;&gt;\nwe will talk about handling errors gracefully in R later when we cover NA handling\nfor now we will .unwrap() the result right away\nadd the return type as String\n\nextendr will handle converting this into a character vector",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#vectorize-geohash-encoding",
    "href": "building-rust-based-r-pkgs/index.html#vectorize-geohash-encoding",
    "title": "Building Rust based R Packages",
    "section": "Vectorize geohash encoding",
    "text": "Vectorize geohash encoding\n\nmodify gh_encode() to take a Vec&lt;f64&gt; for both x and y\nWe will iterate through these together\nreview .zip() to merge iterators\nfor each element in the iterator we encode the geohash\ncollect to strings\nrextendr::document()\ndevtools::load_all()\n\ntest in R\nx &lt;- rnorm(100, -180, 180)\ny &lt;- rnorm(100, -90, 90)\ngh_len &lt;- 7\n\ngh_encode(x, y, gh_len)\n\nWhat about handling errors and NAs?\nGonna need to address type mapping first",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#type-mapping",
    "href": "building-rust-based-r-pkgs/index.html#type-mapping",
    "title": "Building Rust based R Packages",
    "section": "Type Mapping",
    "text": "Type Mapping\n\nvecs are fine for basic stuff.\nR types are more complex and have support for NULL and NA values\nScalar types\nVector types\nNULL in R\nRobj\nRust has the unit type (). We can tu",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#rs-type-system",
    "href": "building-rust-based-r-pkgs/index.html#rs-type-system",
    "title": "Building Rust based R Packages",
    "section": "R’s type system",
    "text": "R’s type system\n\nEverything is an SEXP\nBriefly discuss representations\nI thought really hard on whether or not to discuss this. Initially i thought i wouldnt, but i think it is actually really helpful to understand the fundamental data structures in R. It helps make the mental leaps much easier.\nSo we’re going to spend a few minutes discussing internal representations in R",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#robj-sexp",
    "href": "building-rust-based-r-pkgs/index.html#robj-sexp",
    "title": "Building Rust based R Packages",
    "section": "Robj & SEXP",
    "text": "Robj & SEXP\n\nin extendr, everything can be represented as an Robj\nRobj is an opaque type: we do not know what type it is, we just know its an Robj\na helpful catch-all\nwe can turn any extendr type into an Robj using the .into_robj() method",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#scalars",
    "href": "building-rust-based-r-pkgs/index.html#scalars",
    "title": "Building Rust based R Packages",
    "section": "Scalars",
    "text": "Scalars\n\nNA aware types that correspond to R’s type system\nevery scalar has na() method\n\n\nDoubles\n\ninternally represented by f64\naccess the inner f64 value using .inner()\nConvert f64 to an Rfloat using Rfloat::from(x)",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#strings",
    "href": "building-rust-based-r-pkgs/index.html#strings",
    "title": "Building Rust based R Packages",
    "section": "Strings",
    "text": "Strings\n\nA bit of a nightmare\nCreate Rstr from a String in Rust using Rstr::from(x)",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#using-extendr-types",
    "href": "building-rust-based-r-pkgs/index.html#using-extendr-types",
    "title": "Building Rust based R Packages",
    "section": "Using extendr types",
    "text": "Using extendr types\n\nrewrite gh_encode() to use Doubles and Strings\nwe can leave length as usize for now as it will always be scalar.\nto access the inner value of an Rfloat use .inner()",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#error-handling-in-rust",
    "href": "building-rust-based-r-pkgs/index.html#error-handling-in-rust",
    "title": "Building Rust based R Packages",
    "section": "Error handling in Rust",
    "text": "Error handling in Rust\n\n“And I think Result can be explained fairly quickly in the following way: Rust does not have exceptions. Errors are data. If a function is falliable, it returns Result, which is a fork between the successful value, and the error-as-data. We may ignore the error-branch entirely with .unwrap.” -Mossa\n\n\nHandle errors gracefully on the R side by returning a NULL or NA value when it is appropriate\ndescribe Result&lt;&gt; which is an enum.\nlet’s match on the result from encode()\n\nwhen Ok(gh) use Rstr::from(gh)\nwhen Err(e) use Rstr::na() to record a missing value\n\nwhen we try to encode data that is not in long lat we will get an error—e.g. if its in meter that wont work\nfor the exercise feed some bad data to the function to see it return an NA",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#na-handling",
    "href": "building-rust-based-r-pkgs/index.html#na-handling",
    "title": "Building Rust based R Packages",
    "section": "NA handling",
    "text": "NA handling\n\nnow what about when the coordinates are NA?\nhow do we handle that?\nwe can check Rfloat::is_na()\n\nif either Rfloat::is_na() return Rstr::na()\nelse, do the geohash\n\ntest with NA values",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#geohash-neighbor",
    "href": "building-rust-based-r-pkgs/index.html#geohash-neighbor",
    "title": "Building Rust based R Packages",
    "section": "Geohash Neighbor",
    "text": "Geohash Neighbor\n\nA geohash is a square grid\neach location has up to 6 neighbors\nto find a specific neighbor we can use the neighbor() function\nthis function takes an enum for direction",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#enums-in-r",
    "href": "building-rust-based-r-pkgs/index.html#enums-in-r",
    "title": "Building Rust based R Packages",
    "section": "Enums in R",
    "text": "Enums in R\n\nfirst step, lets make a utility function to take a String and convert this to the enum\n\ngh_neighbor &lt;- function(gh, neighbor = c(\"N\",\"NE\",\"E\",\"SE\",\"S\",\"SW\",\"W\",\"NW\")) {\n  arg.match(neighbor)\n  # function body\n}",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#custom-enum-handling",
    "href": "building-rust-based-r-pkgs/index.html#custom-enum-handling",
    "title": "Building Rust based R Packages",
    "section": "Custom Enum handling",
    "text": "Custom Enum handling\n\nmatch statements can be used on strings too\nthere will be a catch all part of the match\nin the function\n\nfn as_direction(direction: String) -&gt; Direction {\n    match direction.to_lowercase().as_str() {\n        \"n\" =&gt; Direction:N,\n        \"ne\" =&gt; Direction:NE,\n        \"e\" =&gt; Direction:E,\n        \"se\" =&gt; Direction:SE,\n        \"s\" =&gt; Direction:S,\n        \"sw\" =&gt; Direction:SW,\n        \"w\" =&gt; Direction:W,\n        \"nw\" =&gt; Direction:NW,\n        _ =&gt; throw_r_error(\"Invalid geohash neighbor direction\")\n    }\n}",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#single-neighbor-function",
    "href": "building-rust-based-r-pkgs/index.html#single-neighbor-function",
    "title": "Building Rust based R Packages",
    "section": "Single Neighbor function",
    "text": "Single Neighbor function\nExercise\n\nCreate a function gh_decode()\nreturns Option&lt;String&gt;\ntakes 2 args:\n\ngeohash: String\ndirection: String\n\ncast the direction to the Direction enum\npass into the neighbor() function\nIf there is an error in the result, return None\nIf successful return Some(geohash)\ndocument and run the function in R to see the result\ntest with bad data",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#vectorize-the-neighbor-function",
    "href": "building-rust-based-r-pkgs/index.html#vectorize-the-neighbor-function",
    "title": "Building Rust based R Packages",
    "section": "Vectorize the neighbor function",
    "text": "Vectorize the neighbor function\n\nModify gh_decode() to take geohash: Strings\nReturns Strings\nUse .into_iter().map().collect::&lt;String&gt;() to return a vector of neighbors\nHandle NA values for geohash, return an Rstr::na()\nHandle errors return Rstr::na()\nOtherwise return Rstr::from()\nCollect into Strings",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#decoding-a-geohash",
    "href": "building-rust-based-r-pkgs/index.html#decoding-a-geohash",
    "title": "Building Rust based R Packages",
    "section": "Decoding a geohash",
    "text": "Decoding a geohash\n\na geohash isn’t a coordinate, but rather a bounding box\nthe decode() function decodes into a center point and error in two directions\nThe signature is pub fn decode(hash_str: &str) -&gt; Result&lt;(Coord, f64, f64), GeohashError&gt;\nthe Coord is a “generic” struct it has fields x & y and the x & y error\nmost natural way to work with this in R would be to create a data frame\nHow can we create a data frame in extendr?\nthere’s a few ways. We’re going to go ahead and create one from scratch",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#what-is-there-to-a-data.frame",
    "href": "building-rust-based-r-pkgs/index.html#what-is-there-to-a-data.frame",
    "title": "Building Rust based R Packages",
    "section": "What is there to a data.frame?",
    "text": "What is there to a data.frame?\n\ndata.frames are just lists masquerading as a rectangle\n\n\nnamed vectors\nstructs are record based not column based (this is kinda the whole thing about apache arrow)\nHow can we handle this?\nusing an iterator isn’t the most logical for this. Instead, we can use a for loop\nwe can allocate our own vectors and then fill them in a for loop",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#tuples",
    "href": "building-rust-based-r-pkgs/index.html#tuples",
    "title": "Building Rust based R Packages",
    "section": "Tuples",
    "text": "Tuples\n\nThe decode function returns a tuple which we haven’t yet covered.\ntuples are the heterogenous collection type in Rust\nif you’ve used tuples in python they’re pretty much the same\nelements in the tuple are not named\ngenerally good for holding only a handful of items, otherwise just define a struct\nwe access elements from the tuple via .0, .1, .2\nWe can perform destructuring assignment of tuples too which will be handy",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#creating-vectors",
    "href": "building-rust-based-r-pkgs/index.html#creating-vectors",
    "title": "Building Rust based R Packages",
    "section": "Creating vectors",
    "text": "Creating vectors\n\nDoubles, Strings, and Logicals are wrappers around R types\nWe can collect into these types or we can create them\nWe can allocate empty vectors using associated method Doubles::new(usize)\n\nBut filling these is actually somewhat slow due to the FFI boundary\n\nAssociated method Doubles::from_values() to collect values into a vector\n\nStore Vec&lt;Rfloat&gt;\nCollect from the vector",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#creating-data.frames",
    "href": "building-rust-based-r-pkgs/index.html#creating-data.frames",
    "title": "Building Rust based R Packages",
    "section": "Creating data.frames",
    "text": "Creating data.frames\n\nThere are two primary ways of creating data.frames in extendr\nI recommend using the data_frame!() macro\nthis returns an untyped R object: Robj\n\n\n\nExercise\n\ncreate 4 empty vectors to store:\n\nx, y, x_error, y_error\n\nCreate a for loop on the geohash note you have to call .into_iter() explicitly\n\n\nfn gh_decode(geohash: Strings) -&gt; Robj {\n    let mut x_res = Vec::new();\n    let mut y_res = Vec::new();\n    let mut x_error = Vec::new();\n    let mut y_error = Vec::new();\n\n    for gh in geohash.into_iter() {\n        let resi = decode(gh);\n        match resi {\n            Ok((Coord { x, y }, xe, ye)) =&gt; {\n                x_res.push(Rfloat::from(x));\n                y_res.push(Rfloat::from(y));\n                x_error.push(Rfloat::from(xe));\n                y_error.push(Rfloat::from(ye));\n            }\n            Err(_) =&gt; {\n                x_res.push(Rfloat::na());\n                y_res.push(Rfloat::na());\n                x_error.push(Rfloat::na());\n                y_error.push(Rfloat::na());\n            }\n        }\n    }\n\n    data_frame!(\n        x = Doubles::from_values(x_res),\n        y = Doubles::from_values(y_res),\n        x_error = Doubles::from_values(x_error),\n        y_error = Doubles::from_values(y_error)\n    )\n}",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#geohash-neighbors",
    "href": "building-rust-based-r-pkgs/index.html#geohash-neighbors",
    "title": "Building Rust based R Packages",
    "section": "Geohash Neighbors",
    "text": "Geohash Neighbors\n\nWe already made a vectorized functioon to find neighbors in a single direction.\nbut there is also a function neighbors() that returns a struct Neighbors that has the geohash for all neighbors\nThis would be a nice function to have access to in R\nhow should we do this?\nwe can take a similar approach we did for gh_decode()\nBut that’s a lot of boiler plate!\nThere’s another approach to this\nIntoDataFrameRow trait which we can derive",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#traits",
    "href": "building-rust-based-r-pkgs/index.html#traits",
    "title": "Building Rust based R Packages",
    "section": "Traits",
    "text": "Traits\n\nin the previous workhop we used the #[derive()] attribute to be able to have debug printing\nwhat is a trait?\nare similar to object oriented programming\nthey define behaviors that a type can perform\nthey are how we share behavior across rust libraries\nthey’re common methods that can be implemented for any type you own\nmany traits can be “derived” this means you can get them on your type “for free” without doing work",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#deriving-intodataframerow-for-neighbors",
    "href": "building-rust-based-r-pkgs/index.html#deriving-intodataframerow-for-neighbors",
    "title": "Building Rust based R Packages",
    "section": "Deriving IntoDataFrameRow for Neighbors",
    "text": "Deriving IntoDataFrameRow for Neighbors\n\nlets try deriving it\nlol oops! That sucks! we cant implement traits for types we don’t own.\nthis is called the “orphan rule”",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#work-around-create-your-own-struct",
    "href": "building-rust-based-r-pkgs/index.html#work-around-create-your-own-struct",
    "title": "Building Rust based R Packages",
    "section": "Work-around: create your own struct",
    "text": "Work-around: create your own struct\n\none way to handle this is to create your own struct that you can implement traits on\nwe can create our own struct GHNeighbors\nSince we own GHNeighbors we can derive IntoDataFrameRow for it\nbut how do we go from Neighbors to GHNeighbors?\nwe can implement a trait From",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#from-trait",
    "href": "building-rust-based-r-pkgs/index.html#from-trait",
    "title": "Building Rust based R Packages",
    "section": "From trait",
    "text": "From trait\n\npart of the standard library\nthis provides a 0-cost abstraction\nlets us go from T to U without incurring any runtime cost\nuse the impl keyword to implement a trait\nimpl Trait for OurType\nThe From trait requires us to specify a type:\nimpl From&lt;ForeignType&gt; for OurType\n\n\nExample\nimpl From&lt;Coord&lt;f64&gt;&gt; for Point {\n    fn from(value: Coord&lt;f64&gt;) -&gt; Self {\n        Point {\n            x: Rfloat::from(value.x),\n            y: Rfloat::from(value.y),\n        }\n    }\n}\nThis lets us do something like:\nlet coord = Coord::zero();\nlet p = Point::from(coord);\nPro-tip if you write:\nimpl From&lt;T&gt; for U {\n    // have cursor here and type `cmd + .`\n}\n\nThis opens the “Quick fix”\npress “implement missing members” which fills the template:\n\nimpl From&lt;T&gt; for U {\n    fn from(value: T) -&gt; Self {\n        // construct Self / U struct here\n        todo!()\n    }\n}",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#default-trait",
    "href": "building-rust-based-r-pkgs/index.html#default-trait",
    "title": "Building Rust based R Packages",
    "section": "Default trait",
    "text": "Default trait\n\nwhat happens when we run into an error finding the neighbors?\nwe want to be able to return a row of NAs\nrather than constructing the whole thing from struct each time we want to use a full row of NA\nwe can actually instead, implement a default value\nnote often the default trait can be derived\n\n\nExample\nimpl Default for Point {\n    fn default() -&gt; Self {\n        Self {\n            x: Rfloat::na(),\n            y: Rfloat::na(),\n        }\n    }\n}\n\n\nExercise\nImplement the Default trait for GHNeighbors\nimpl Default for GHNeighbors {\n    fn default() -&gt; Self {\n        Self {\n            sw: Rstr::na(),\n            s: Rstr::na(),\n            se: Rstr::na(),\n            w: Rstr::na(),\n            e: Rstr::na(),\n            nw: Rstr::na(),\n            n: Rstr::na(),\n            ne: Rstr::na(),\n        }\n    }\n}\nThis lets us write GHNeighbors::default()",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#put-it-all-together",
    "href": "building-rust-based-r-pkgs/index.html#put-it-all-together",
    "title": "Building Rust based R Packages",
    "section": "Put it all together",
    "text": "Put it all together\n\nlets combine the use of our implementations of From, Default, and IntoDataFrameRow row to write gh_neighbors()\n\n\nExercise\n#[extendr]\nfn gh_neighbors(geohashes: Strings) -&gt; Robj {\n    let all_rows = geohashes\n        .into_iter()\n        .map(|gh| match neighbors(gh.as_str()) {\n            Ok(nbs) =&gt; GHNeighbors::from(nbs),\n            Err(_) =&gt; GHNeighbors::default(),\n        })\n        .collect::&lt;Vec&lt;_&gt;&gt;();\n\n    all_rows.into_dataframe().unwrap().into_robj()\n}",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#you-help-me-choose-what-to-do-next",
    "href": "building-rust-based-r-pkgs/index.html#you-help-me-choose-what-to-do-next",
    "title": "Building Rust based R Packages",
    "section": "You help me choose what to do next",
    "text": "You help me choose what to do next\n\nQ&A?\nThe last function but independently?\nCRAN compatibility?",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#all-on-your-own-now",
    "href": "building-rust-based-r-pkgs/index.html#all-on-your-own-now",
    "title": "Building Rust based R Packages",
    "section": "All on your own now",
    "text": "All on your own now\n\nthe decode_bbox() function",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#cran-compatibility",
    "href": "building-rust-based-r-pkgs/index.html#cran-compatibility",
    "title": "Building Rust based R Packages",
    "section": "CRAN Compatibility",
    "text": "CRAN Compatibility\n\nvendoring\nMSRV",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#using-github-actions",
    "href": "building-rust-based-r-pkgs/index.html#using-github-actions",
    "title": "Building Rust based R Packages",
    "section": "Using GitHub Actions",
    "text": "Using GitHub Actions\n\nR CMD check\nCRAN checks",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#thank-you",
    "href": "building-rust-based-r-pkgs/index.html#thank-you",
    "title": "Building Rust based R Packages",
    "section": "Thank you",
    "text": "Thank you\n\nJoin our Discord\n\n\n\n\nView solution",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/objective.html",
    "href": "building-rust-based-r-pkgs/objective.html",
    "title": "20  Workshop Scope",
    "section": "",
    "text": "What is geohashing?\nThere’s no better way to learn than by doing.\nIn this workhop we will learn how to use extendr and create Rust-powered R package by creating a new package called {geohashrs}. The {geohashrs} R package will provide R bindings to the geohash crate.\nThroughout the workshop we will touch on:\nAs much as this is about Rust, we are also working within the confines of R and thus, he two are inextricably linked.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Workshop Scope</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr-dx.html",
    "href": "building-rust-based-r-pkgs/extendr-dx.html",
    "title": "23  Developer Experience",
    "section": "",
    "text": "Viewing Problems\nThe use_extendr() function creates will create (or update) the settings.json file in Positron & VS Code. This lets the rust-analyzer find the Rust package. Rust files are automatically linted and checked for errors.\nThe rust-analyzer is always running and identifies errors and warnings as you write them.\nYou can diagnose and identify issues in your Rust code by using the problems tab.\nOr, alternatively, you can run cargo check from the terminal to get diagnostics that way. This is my preference, personally.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Developer Experience</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/encode.html",
    "href": "building-rust-based-r-pkgs/encode.html",
    "title": "26  Encoding a geohash",
    "section": "",
    "text": "encode()\nIn the previous exercise we printed the Coord struct. Now, lets continue the function by calling the encode() function from Rust.\nThe geohash::encode() function has the following signature:\nInstead of returning a String we get a Result&lt;&gt;. In Rust, errors are data and should be handled.\nFor now, we’re going to ignore the possibility that an error may ever occur (we’re perfect anyways, right? 💅). Results are actually a special type of enum with the structure of\nEach variant of a result holds some data. If the Result was okay (meaning no error), it contains the expected type. Otherwise, it returns the specified error type.\nIn Rust, we can .unwrap() or .expect(\"Expectation message\") both Option&lt;T&gt; and Result&lt;T&gt;. So, for this case, we will do just that.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Encoding a geohash</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/vectorize.html",
    "href": "building-rust-based-r-pkgs/vectorize.html",
    "title": "28  Vectorizing",
    "section": "",
    "text": "Combining iterators with .zip()\nR users expect vectorized functions. In a high-level language like R “vectorized” simply means implementing the underlying loop in a compiled language like C/++ or Rust.\nIn the previous workshop we used .iter() and .into_iter() to iterate through single vectors. In this case we need to iterate through two vectors. How can we accomplish this?\nIt is possible to combine iterators in Rust using .zip().\nWe can combine iterators using the following syntax:\n.zip() modifies each element of the iterator to be a tuple with two elements.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Vectorizing</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/r-type-system.html",
    "href": "building-rust-based-r-pkgs/r-type-system.html",
    "title": "29  R’s Type System",
    "section": "",
    "text": "Vector SEXP types\nIn R, everything is an SEXP.\nTo extendr, an SEXP is an Robj—it can be anything.\nThere are a subset of SEXP types that we actually care about—the vector kinds. For the sake of simplicity, we’ll only talk about the numeric vector types.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>R's Type System</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/using-extendr-types.html",
    "href": "building-rust-based-r-pkgs/using-extendr-types.html",
    "title": "30  Collecting extendr types",
    "section": "",
    "text": "Example\nWe’ve been using .collect() to create vectors of a return type. However, these are not native R types. Using Vec&lt;T&gt; requires allocating a new (R) vector and filling the values.\nInstead, we can collect into the wrapper types. To do so, the iterator must be a scalar type—e.g. Rfloat, Rint, or Rstr.\nRather than .collect::&lt;Vec&lt;_&gt;&gt;() we specify the wrapper type we want.\nUsing the previous parallel sum, we can instead return Doubles using the turbo-fish syntax",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Collecting extendr types</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/ffi.html",
    "href": "building-rust-based-r-pkgs/ffi.html",
    "title": "18  Foreign Function Interfaces (FFI)",
    "section": "",
    "text": "R’s C API\nForeign function interfaces (FFI) are mechanisms by which other (foreign) languages can be used in our programming langauge of choice. They are typically used to call compiled languages (like C / Rust) from an interpretted langauge (R).\nMuch of R’s success and power comes from a robust FFI tooling ecosystem. Some of the more prominent FFI libraries are:\nMost langauges have the ability to interact with C and C-types. R is written in C and exposes a C API. Rust is able to work with C and represent C types. This is where extendr comes in.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Foreign Function Interfaces (FFI)</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr.html",
    "href": "building-rust-based-r-pkgs/extendr.html",
    "title": "19  What is extendr?",
    "section": "",
    "text": "extendr-ffi\nextendr is a project that focuses on extending R with Rust. It is comprised of:\nextendr-ffi defines the types and functions in R’s C API using Rust functions and types. As R’s C API changes, extendr-ffi is responsible for ensuring that packages are backwards compatible.\nFortunately, we will never have to touch this layer. Everything is built on top of this crate.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>What is extendr?</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr.html#extendr-ffi",
    "href": "building-rust-based-r-pkgs/extendr.html#extendr-ffi",
    "title": "21  What is extendr?",
    "section": "",
    "text": "extendr-ffi is a crate that does the translation between R and Rust.\nR has many functions and types that are defined in C\nextendr-ffi provides Rust-compatible type definitions for the low-level C API\nwe will never have to touch this\nbut everything is built upon this layer",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>What is extendr?</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr.html#extendr-api",
    "href": "building-rust-based-r-pkgs/extendr.html#extendr-api",
    "title": "19  What is extendr?",
    "section": "extendr-api",
    "text": "extendr-api\nextendr-api is the high-level crate that is built upon extendr-ffi. It makes working with R types such as vectors feel fairly natural from a Rust perspective. It handles the oddities of garbage collection and everything else related to the FFI boundary.\nWe will spend the rest of the workshop using the extendr-api crate.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>What is extendr?</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr.html#extendr-engine",
    "href": "building-rust-based-r-pkgs/extendr.html#extendr-engine",
    "title": "19  What is extendr?",
    "section": "extendr-engine",
    "text": "extendr-engine\nThe extendr-engine is focused on the opposite direction—calling R from Rust. It enables us to start an R process inside of Rust as well as execute R code in that R process. It can be used in creating Rust-based CLI tools that call R or whatever else your imagination can think up.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>What is extendr?</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr.html#rextendr",
    "href": "building-rust-based-r-pkgs/extendr.html#rextendr",
    "title": "19  What is extendr?",
    "section": "{rextendr}",
    "text": "{rextendr}\nOn the R side exists {rextendr}. It is a {usethis}-like package for developing Rust-powered R packages.\nIt is primarily used to:\n\nscaffold R packages\ndocument Rust functions\nprepare packages for CRAN release\n\nIt also provide a knitr-engine which lets us include Rust in R Markdown documents.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>What is extendr?</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/objective.html#what-is-geohashing",
    "href": "building-rust-based-r-pkgs/objective.html#what-is-geohashing",
    "title": "20  Workshop Scope",
    "section": "",
    "text": "Geohashes are a way to encode a location on earth as a string of 1 - 12 characters.\nThe more shared characters there are between two geohashes, the closes in physical space the geohashes are.\nUsed to find approximately near locations.\nUsed frequently in databases and web development to quickly query results.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Workshop Scope</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/hello-world.html",
    "href": "building-rust-based-r-pkgs/hello-world.html",
    "title": "21  Hello, world!",
    "section": "",
    "text": "Developer functions\nWe’re now ready to create our R package.\nTo develop a Rust-based R package, there are a few functions we need to familiarize ourselves with.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Hello, world!</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/hello-world.html#rextendr-developer-functions",
    "href": "building-rust-based-r-pkgs/hello-world.html#rextendr-developer-functions",
    "title": "22  Hello, world!",
    "section": "",
    "text": "rextendr::use_extendr() - create the Rust infrastructure\nrextendr::document() - document and update Rust function definitions",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Hello, world!</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/hello-world.html#developer-workflow",
    "href": "building-rust-based-r-pkgs/hello-world.html#developer-workflow",
    "title": "21  Hello, world!",
    "section": "Developer workflow",
    "text": "Developer workflow\nThe typical workflow for developing an extendr package involves:\n\nModify the Rust source code\nUpdate the bindings documentation using rextendr::document()\nLoad the package devtools::load_all()\nTest the R functions\nRepeat",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Hello, world!</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/hello-world.html#exercise",
    "href": "building-rust-based-r-pkgs/hello-world.html#exercise",
    "title": "21  Hello, world!",
    "section": "Exercise",
    "text": "Exercise\n\nCreate a new package called {geohashrs} using {usethis}\nInclude extendr in the new package by running rextendr::use_extendr()\nCompile the package by using rextendr::document()\nLoad the package using devtools::load_all()\nRun hello_world()\n\n\nSolution\n\n\nView solution\n\nusethis::create_package(\"geohashrs\")\n# in the newly created package\nlibrary(rextendr)\n\n# add extendr scaffolding\nuse_extendr()\n\n# compile and document the Rust functions\ndocument()\n\n# load the R package\ndevtools::load_all()\n\n# run the hello_world()!\nhello_world()",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Hello, world!</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/export-to-r.html",
    "href": "building-rust-based-r-pkgs/export-to-r.html",
    "title": "27  Calling Rust from R",
    "section": "",
    "text": "View solution",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Calling Rust from R</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/decode.html",
    "href": "building-rust-based-r-pkgs/decode.html",
    "title": "36  Decode a geohash",
    "section": "",
    "text": "View solution",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Decode a geohash</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/vectorize-neighbor.html",
    "href": "building-rust-based-r-pkgs/vectorize-neighbor.html",
    "title": "35  Vectorize gh_neighbor()",
    "section": "",
    "text": "Exercise 1\nWe’ll now focus on vectorizing the gh_neighbor() function using the same approach we took for gh_encode().\nThe objective of this exercise is to vectorize the gh_neighbor() function. You an do this by:",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Vectorize `gh_neighbor()`</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/type-mapping-p1.html",
    "href": "building-rust-based-r-pkgs/type-mapping-p1.html",
    "title": "30  Type Mapping",
    "section": "",
    "text": "View solution",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Type Mapping</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/rust-deps.html",
    "href": "building-rust-based-r-pkgs/rust-deps.html",
    "title": "24  Adding dependencies",
    "section": "",
    "text": "Cargo.toml\nDependencies in Rust are managed by the Cargo.toml file. R will let you use packages that are on your machine even if you do not explicitly declare them as dependencies. Rust will not. You must declare dependencies.\nThe Cargo.toml is akin to the DESCRIPTION file. Dependencies are set via the [dependencies] table.\nWe can add dependencies manually, using cargo add crate-name, or via rextendr::use_crate(\"cratename\").",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Adding dependencies</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/na-handling.html",
    "href": "building-rust-based-r-pkgs/na-handling.html",
    "title": "32  Handle NAs gracefully",
    "section": "",
    "text": "Example\nWe’ve been using xi.inner() to access the f64 value of an Rfloat. This is an infallible method. It always provides the inner value of the Rfloat. However, we may want to handle NA values differently.\nTo handle NA values explicitly (rather than hoping our encode() function returns an error), we can check for the pressence of NA in both xi and yi. We can then match on the boolean value and choose what to do!\nmatch isn’t only for enums! When we match on booleans, there are only two variants: true or false. We can also perform nested match statements!\nHere we perform a nested match statement on the Result from parsing a string slice to an integer.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Handle NAs gracefully</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr-structure.html",
    "href": "building-rust-based-r-pkgs/extendr-structure.html",
    "title": "22  Package structure",
    "section": "",
    "text": "Compiled Code\nThe basic structure of an extendr-based R package is like so:\nR packages that have compile code must store the source in src/. The src/ directory has the structure:",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Package structure</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr-structure.html#using-compiled-code",
    "href": "building-rust-based-r-pkgs/extendr-structure.html#using-compiled-code",
    "title": "22  Package structure",
    "section": "",
    "text": "compiled code has to be placed in the src/ directory\n\n.\n├── Makevars\n├── Makevars.in\n├── Makevars.win.in\n└── rust\n    ├── Cargo.lock\n    ├── Cargo.toml\n    ├── src\n\ninside of src/ there is a directory called rust\n\nthis contains a rust library crate\nprevious workshop we create a binary crate—something that can be run right away\nlibraries are typically included into other libraries or binaries and compiled together\nin our case, we are building a shared object / dll that is linked to by R\n\nVarious Makevars files are used to compile the R package and link to the generated rust library that we develop.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Package structure</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr-structure.html#rust-libraries",
    "href": "building-rust-based-r-pkgs/extendr-structure.html#rust-libraries",
    "title": "22  Package structure",
    "section": "Rust libraries",
    "text": "Rust libraries\nRust library crates have lib.rs instead of main.rs. There is no entrypoint that gets executed. Instead, we define functions, structs, enums, etc. that are used by the R package.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Package structure</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/objective.html#the-r-package",
    "href": "building-rust-based-r-pkgs/objective.html#the-r-package",
    "title": "20  Workshop Scope",
    "section": "The R package",
    "text": "The R package\nThe R package we will create will help us:\n\nencode geohashes\ndecoded geohash to x & y plus error terms\ndecode geohash into a bounding box\nfind geohash neighbors",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Workshop Scope</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/hello-world.html#developer-functions",
    "href": "building-rust-based-r-pkgs/hello-world.html#developer-functions",
    "title": "21  Hello, world!",
    "section": "",
    "text": "I don’t use RStudio anymore so I set create_package(rstudio = FALSE) to not have Rproj.user created.\n\nusethis::create_package() creates an R package\nrextendr::use_extendr() creates the Rust infrastructure\nrextendr::document() document and update Rust function definitions",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Hello, world!</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr-structure.html#compiled-code",
    "href": "building-rust-based-r-pkgs/extendr-structure.html#compiled-code",
    "title": "22  Package structure",
    "section": "",
    "text": ".\n├── Makevars\n├── Makevars.in\n├── Makevars.win.in\n└── rust\n    ├── Cargo.lock\n    ├── Cargo.toml\n    ├── src\n\nrust/ is library crate that is linked to by R\nMakevars files builds the Rust library and links it to R",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Package structure</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr-dx.html#viewing-problems",
    "href": "building-rust-based-r-pkgs/extendr-dx.html#viewing-problems",
    "title": "23  Developer Experience",
    "section": "",
    "text": "Problems Tab\n\n\n\ncd src/rust\ncargo check\n\n\n\ncargo check\n\n\n\n\n\n\n\n\ncargo check Keyboard shortcut\n\n\n\n\n\nI have a user task and keybinding to run cargo check in extendr packages that I find quite nice.\nOpen the command pallete using cmd + shift + p and find Tasks: Open User Tasks and add this task.\n{\n    \"label\": \"Check extendr package\",\n    \"type\": \"shell\",\n    \"command\": \"cargo check --all-features --manifest-path=src/rust/Cargo.toml\",\n}\nYou can bind this task to a keyboard shortcut. I use shift + cmd + enter and the condition that the directory is an R package and the open editor is a rust file.\n{\n    \"key\": \"shift+cmd+enter\",\n    \"command\": \"workbench.action.tasks.runTask\",\n    \"args\": \"Check extendr package\",\n    \"when\": \"isRPackage && editorLangId == 'rust'\",\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Developer Experience</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr-dx.html#cargo-check-keyboard-shortcut",
    "href": "building-rust-based-r-pkgs/extendr-dx.html#cargo-check-keyboard-shortcut",
    "title": "23  Developer Experience",
    "section": "",
    "text": "I have a user task and keybinding to run cargo check in extendr packages that I find quite nice.\nOpen the command pallete using cmd + shift + p and find Tasks: Open User Tasks and add this task.\n{\n    \"label\": \"Check extendr package\",\n    \"type\": \"shell\",\n    \"command\": \"cargo check --all-features --manifest-path=src/rust/Cargo.toml\",\n}\nYou can bind this task to a keyboard shortcut. I use shift + cmd + enter and the condition that the directory is an R package and the open editor is a rust file.\n{\n    \"key\": \"shift+cmd+enter\",\n    \"command\": \"workbench.action.tasks.runTask\",\n    \"args\": \"Check extendr package\",\n    \"when\": \"isRPackage && editorLangId == 'rust'\",\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Developer Experience</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr-dx.html#exercise",
    "href": "building-rust-based-r-pkgs/extendr-dx.html#exercise",
    "title": "23  Developer Experience",
    "section": "Exercise",
    "text": "Exercise\n\nRun cargo check in the src/rust directory",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Developer Experience</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/rust-deps.html#cargo.toml",
    "href": "building-rust-based-r-pkgs/rust-deps.html#cargo.toml",
    "title": "24  Adding dependencies",
    "section": "",
    "text": "[package]\nname = \"geohash\"\npublish = false\nversion = \"0.1.0\"\nedition = \"2021\"\nrust-version = \"1.65\"\n\n[lib]\ncrate-type = [ \"staticlib\" ]\nname = \"geohashrs\"\n\n[dependencies]\nextendr-api = \"*\"\n\n\nRust dependencies use semantic versionining (semver). The \"*\" is a shorthand for specifying the latest stable release.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Adding dependencies</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/rust-deps.html#importing-items-from-dependenceis",
    "href": "building-rust-based-r-pkgs/rust-deps.html#importing-items-from-dependenceis",
    "title": "24  Adding dependencies",
    "section": "Importing items from dependenceis",
    "text": "Importing items from dependenceis\nWhen dependencies are added to a crate, the items from the dependency are accessed via namespace similar to R. If we look at lib.rs we see at the top\nuse extendr_api::prelude::*;\nThis has the format of crate_name::module::item. The * is a wildcard for importing everything from the module.\nThe prelude is a common module name. It re-exports the commonly used items from a crate all together so you do not have to manually list them.\nMultiple items can be imported using {} for example:\nuse crate_name::{StructName, function_name};",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Adding dependencies</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/rust-deps.html#exercise",
    "href": "building-rust-based-r-pkgs/rust-deps.html#exercise",
    "title": "24  Adding dependencies",
    "section": "Exercise",
    "text": "Exercise\n\nAdd the geohash crate as a dependency\nImport the Coord struct and the encode function from geohash in lib.rs\n\n\n\nView solution\n\nFrom the R terminal run:\nrextendr::use_crate(\"geohash\")\nThis will add the geohash dependency.\nOpen src/rust/lib.rs and add the following below use extendr_api::prelude::*;\nuse geohash::{Coord, encode};",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Adding dependencies</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/rust-deps.html#importing-items-from-dependencies",
    "href": "building-rust-based-r-pkgs/rust-deps.html#importing-items-from-dependencies",
    "title": "24  Adding dependencies",
    "section": "Importing items from dependencies",
    "text": "Importing items from dependencies\nWhen dependencies are added to a crate, the items from the dependency are accessed via namespace similar to R. If we look at lib.rs we see at the top\nuse extendr_api::prelude::*;\nThis has the format of crate_name::module::item. The * is a wildcard for importing everything from the module.\nThe prelude is a common module name. It re-exports the commonly used items from a crate all together so you do not have to manually list them.\nMultiple items can be imported using {} for example:\nuse crate_name::{StructName, function_name};",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Adding dependencies</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/first-fn.html",
    "href": "building-rust-based-r-pkgs/first-fn.html",
    "title": "25  Your first function",
    "section": "",
    "text": "#[extendr]\nFunctions that are callable from R are made available via the lib.rs file. Let’s ensure we understand the general structure of the file before we get started.\nThe hello_world() function has two important things going on:\nIn Rust /// specifies a “doc comment”. They are used to generate documentation. extendr permits you to write roxygen documentation on Rust functions. These will be rendered by roxygen and rextendr::document().\nSecondly, and most importantly, is the #[extendr] attribute. This attribute macro ensures that the function can be exported to R. It also ensures that the inputs and outputs are compatible with R.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Your first function</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/first-fn.html#extendr",
    "href": "building-rust-based-r-pkgs/first-fn.html#extendr",
    "title": "25  Your first function",
    "section": "",
    "text": "roxygen2 documentation\n#[extendr] attribute\n\n/// Return string `\"Hello world!\"` to R.\n/// @export\n#[extendr]\nfn hello_world() -&gt; &'static str {\n    \"Hello world!\"\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Your first function</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/first-fn.html#extendr_module",
    "href": "building-rust-based-r-pkgs/first-fn.html#extendr_module",
    "title": "25  Your first function",
    "section": "extendr_module! {}",
    "text": "extendr_module! {}\nAdding #[extendr] alone is not sufficient for the function to be made available to R. It needs to be added to the extendr_module! {} macro.\nThis macro (note the !) ha the first argument being the mod geohashrs which is the name of the R package. Subsequent arguments are functions that are exported.\n// Macro to generate exports.\n// This ensures exported functions are registered with R.\n// See corresponding C code in `entrypoint.c`.\nextendr_module! {\n    mod geohashrs;\n    fn hello_world;\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Your first function</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/first-fn.html#exercise",
    "href": "building-rust-based-r-pkgs/first-fn.html#exercise",
    "title": "25  Your first function",
    "section": "Exercise",
    "text": "Exercise\n\nDelete hello_world() from your package\nCreate a new function gh_encode() that takes x: f64 and y: f64 without a return type\nConstruct a Coord struct\nUse rprintln!() to print the debug representation of the Coord\nAdd the gh_encode function to extendr_module! and rextendr::document() your package\nRun gh_encode() from R\n\n\n\n\n\n\n\nUse rprintln!() instead of println!() to print to the R console.\n\n\n\n\n\nView solution\n\nIn src/rust/lib.rs\nuse extendr_api::prelude::*;\n\n#[extendr]\nfn gh_encode(x: f64, y: f64) {\n    let coord = Coord { x, y };\n    rprintln!(\"{coord:?}\");\n}\n\nextendr_module! {\n    mod geohashrs;\n    fn gh_encode;\n}\nAfter modifying lib.rs run `\nrextendr::document()\ndevtools::load_all()\n\ngh_encode(3.0, 0.14)",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Your first function</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/encode.html#encode",
    "href": "building-rust-based-r-pkgs/encode.html#encode",
    "title": "26  Encoding a geohash",
    "section": "",
    "text": "pub fn encode(c: Coord, len: usize) -&gt; Result&lt;String, GeohashError&gt;\n\n\nenum Result {\n    Ok(T),\n    Err(E)\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Encoding a geohash</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/encode.html#exercise",
    "href": "building-rust-based-r-pkgs/encode.html#exercise",
    "title": "26  Encoding a geohash",
    "section": "Exercise",
    "text": "Exercise\n\nAdd an argument length: usize to gh_encode()\nSpecify the return type to be String\nUse geohash::encode() on the constructed Coord with the specified length\nUnwrap the result and return the inner String\n\n\n\nView solution\n\nModify your src/lib.rs file to have:\n#[extendr]\nfn gh_encode(x: f64, y: f64, length: usize) -&gt; String {\n    let coord = Coord { x, y };\n    encode(coord, length).unwrap()\n}\nRun rextendr::document() and devtools::load_all() to register the changes to your function.\nRun gh_encode(3.0, 0.14, 10L) with your new function.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Encoding a geohash</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/throwing-errors.html",
    "href": "building-rust-based-r-pkgs/throwing-errors.html",
    "title": "27  Throwing errors",
    "section": "",
    "text": "Exercise\nSo far we have not been performing any validation of our inputs.\nIf we pass an incorrect value to geohash::encode() we will receive an error. There are 3 ways that we can receive an error:\nIn a moment we will vectorize on x and y but not on length. So, let’s perform some validation.\nWe can use throw_r_error(\"error message\") to emit an error directly from Rust.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Throwing errors</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/throwing-errors.html#exercise",
    "href": "building-rust-based-r-pkgs/throwing-errors.html#exercise",
    "title": "27  Throwing errors",
    "section": "",
    "text": "Add a validation step in gh_encode() the ensures length is within the range [1, 12]\nIf length is an invalid value, emit an error using throw_r_error()\n\n\n\nView solution\n\nModify your src/lib.rs file to have:\n#[extendr]\nfn gh_encode(x: f64, y: f64, length: usize) -&gt; String {\n    if length == 0 || length &gt; 12 {\n        throw_r_error(\"`length` must be between 1 and 12\");\n    }\n\n    let coord = Coord { x, y };\n    encode(coord, length).unwrap()\n}\nRun rextendr::document() and devtools::load_all() to register the changes to your function.\nRun gh_encode(3.0, 0.14, 100L) with your new function.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Throwing errors</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/vectorize.html#combining-iterators-with-.zip",
    "href": "building-rust-based-r-pkgs/vectorize.html#combining-iterators-with-.zip",
    "title": "28  Vectorizing",
    "section": "",
    "text": "x.into_iter().zip(y.into_iter())",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Vectorizing</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/vectorize.html#tuples",
    "href": "building-rust-based-r-pkgs/vectorize.html#tuples",
    "title": "28  Vectorizing",
    "section": "Tuples",
    "text": "Tuples\nTuples are the fundamental heterogenous data type for Rust. They’re much like tuples in Python.\nlet my_tuple = (1.0, \"One\");\nEach element of the tuple can be accessed as if they were fields in a struct. To access the first element of the tuple we can use my_tuple.0 and the second with my_tuple.1.\nTuples can be destructured in assignment too!\nlet my_tuple = (1.0, \"One\");\nlet (one_one, one_two) = my_tuple;",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Vectorizing</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/vectorize.html#destructuring-in-an-iterator",
    "href": "building-rust-based-r-pkgs/vectorize.html#destructuring-in-an-iterator",
    "title": "28  Vectorizing",
    "section": "Destructuring in an iterator",
    "text": "Destructuring in an iterator\nFor example to find the parallel sum between two vectors:\nfn psum(x: Vec&lt;f64&gt;, y: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; {\n    x\n        .into_iter()\n        .zip(y.into_iter())\n        // destructure tuple in the closure\n        .map(|(xi, yi)| {\n            xi + yi\n        })\n        .collect::&lt;Vec&lt;_&gt;&gt;()\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Vectorizing</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/vectorize.html#exercise",
    "href": "building-rust-based-r-pkgs/vectorize.html#exercise",
    "title": "28  Vectorizing",
    "section": "Exercise",
    "text": "Exercise\n\nModify x and y to be Vec&lt;f64&gt;\nChange the return type to be Vec&lt;String&gt;\nCreate a zipped iterator for x and y\nMap through the iterator and:\n\ndestructure the tuple in the closure (as in the above example)\nCreate a Coord struct in each iteration\nencode() the coordinate\nunwrap the result\n\nCollect the iterator into a Vec&lt;String&gt;\nTest this in R\n\n\n\n\n\n\n\nGenerating random points\n\n\n\nTo help you test this function, I recommend using the following code:\nn &lt;- 10\nx &lt;- runif(n, -180, 180)\ny &lt;- runif(n, -90, 90)\n\ngh_encode(x, y, 10L)\n\n\n\n\nView solution\n\n#[extendr]\nfn gh_encode(x: Vec&lt;f64&gt;, y: Vec&lt;f64&gt;, length: usize) -&gt; Vec&lt;String&gt; {\n\n    if length == 0 || length &gt; 12 {\n        throw_r_error(\"`length` must be between 1 and 12\");\n    }\n\n    x\n        .into_iter()\n        .zip(y.into_iter())\n        .map(|(xi, yi)| {\n            let coord = Coord { x: xi, y: yi };\n            encode(coord, length)\n                .expect(\"Failed to encode the geohash\")\n        })\n        .collect::&lt;Vec&lt;_&gt;()\n}\nRun rextendr::document() and devtools::load_all() to register the changes to your function.\nn &lt;- 10\nx &lt;- runif(n, -180, 180)\ny &lt;- runif(n, -90, 90)\n\ngh_encode(x, y, 10L)",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Vectorizing</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/r-type-system.html#vector-sexp-types",
    "href": "building-rust-based-r-pkgs/r-type-system.html#vector-sexp-types",
    "title": "29  R’s Type System",
    "section": "",
    "text": "SEXP numeric types\n\n\n\nIntegers are represented by 32 bit integers i32 in Rust.\nDoubles are represented by 64 bit floats f64 in Rust.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>R's Type System</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/r-type-system.html#scalar-types",
    "href": "building-rust-based-r-pkgs/r-type-system.html#scalar-types",
    "title": "29  R’s Type System",
    "section": "Scalar types",
    "text": "Scalar types\ni32 and f64 do not have a concept of NA or missing. How do we address this?\nextendr provides scalar types such as:\n\nRfloat\nRint\nRstr\nRbool\n\nand others.\nThese scalar types are created using ScalarType::from(). For example:\nlet my_float = Rfloat::from(3.14);\nOr, NAs can be created explicitly by using the associated method ScalarType::na()\nlet my_na = Rfloat::na();\n\nMissingness can also be checked by using the my_na.is_na() method.\nTo access the inner type—e.g. f64 or i32 we can use the .inner() method.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>R's Type System</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/r-type-system.html#wrapper-types",
    "href": "building-rust-based-r-pkgs/r-type-system.html#wrapper-types",
    "title": "29  R’s Type System",
    "section": "Wrapper types",
    "text": "Wrapper types\nTo work with vectors, we work with their wrapper types. These are:\n\nDoubles\nIntegers\nLogicals\nStrings\n\nWe should always prefer these types over using Vec&lt;f64&gt; or Vec&lt;i32&gt;.\n\n\n\n\n\n\nWhen in doubt, clone it out\n\n\n\n\n\nCloning an extendr Robj (or other wrapper type) is quite cheap. When cloning an Robj, we are only incrementing a reference count and not performing a full copy like we do when working in R.\n\n\n\n\n\n\nWrapper types",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>R's Type System</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/r-type-system.html#exercise",
    "href": "building-rust-based-r-pkgs/r-type-system.html#exercise",
    "title": "29  R’s Type System",
    "section": "Exercise",
    "text": "Exercise\n\nRewrite gh_encode() to use Doubles for both the x and y argument\nStill return Vec&lt;String&gt;\n\n\nSolution\n\n\nView hint\n\nUse .inner() to access the f64 value from xi and yi.\n\n\n\nView solution\n\n#[extendr]\nfn gh_encode(x: Doubles, y: Doubles, length: usize) -&gt; Vec&lt;String&gt; {\n    if length == 0 || length &gt; 12 {\n        throw_r_error(\"`length` must be between 1 and 12\");\n    }\n\n    x.into_iter()\n        .zip(y.into_iter())\n        .map(|(xi, yi)| {\n            let coord = Coord {\n                x: xi.inner(),\n                y: yi.inner(),\n            };\n            encode(coord, length).unwrap()\n        })\n        .collect::&lt;Vec&lt;_&gt;&gt;()\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>R's Type System</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/using-extendr-types.html#example",
    "href": "building-rust-based-r-pkgs/using-extendr-types.html#example",
    "title": "30  Collecting extendr types",
    "section": "",
    "text": "#[extendr]\nfn psum(x: Doubles, y: Doubles) -&gt; Doubles {\n    x.into_iter()\n        .zip(y.into_iter())\n        .map(|(xi, yi)| Rfloat::from(xi.inner() + yi.inner()))\n        .collect::&lt;Doubles&gt;()\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Collecting extendr types</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/using-extendr-types.html#exercise",
    "href": "building-rust-based-r-pkgs/using-extendr-types.html#exercise",
    "title": "30  Collecting extendr types",
    "section": "Exercise",
    "text": "Exercise\n\nModify gh_encode() so that it returns Strings\nEnsure that each iteration returns an Rstr instead of String\n\n\n\nView solution\n\n#[extendr]\nfn gh_encode(x: Doubles, y: Doubles, length: usize) -&gt; Strings {\n    if length == 0 || length &gt; 12 {\n        throw_r_error(\"`length` must be between 1 and 12\");\n    }\n\n    x.into_iter()\n        .zip(y.into_iter())\n        .map(|(xi, yi)| {\n            let coord = Coord {\n                x: xi.inner(),\n                y: yi.inner(),\n            };\n            let gh = encode(coord, length).unwrap();\n            Rstr::from(gh)\n        })\n        .collect::&lt;Strings&gt;()\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Collecting extendr types</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/error-handling.html",
    "href": "building-rust-based-r-pkgs/error-handling.html",
    "title": "31  Handling Errors",
    "section": "",
    "text": "Errors are data\nMany times when we use a function or a method, the result is fallible. A fallible function is one in which an error may occur. An infallible function will always return a valid value for example fn add2(x: f64, y: f64) -&gt; f64.\nErrors cannot happen quietly in Rust. They must be handled. In Rust, errors are data. When an error is possible a function should return a Result.\nA Result, is a special type of enum that has two variants:\nEnums can contain data. In the case of the Result&lt;T, E&gt;, when a function completes successfully, the variant is called Ok(). When an error is occurred the variant is called Err().\nTo access the values of the Result&lt;T, E&gt;, we can match on the enum variants.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Handling Errors</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/error-handling.html#errors-are-data",
    "href": "building-rust-based-r-pkgs/error-handling.html#errors-are-data",
    "title": "31  Handling Errors",
    "section": "",
    "text": "enum Result {\n    Ok(T),\n    Err(E)\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Handling Errors</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/error-handling.html#example",
    "href": "building-rust-based-r-pkgs/error-handling.html#example",
    "title": "31  Handling Errors",
    "section": "Example",
    "text": "Example\nfn main() {\n    let number_str = \"10 0 0\";\n    let number = match number_str.parse::&lt;i32&gt;() {\n        Ok(number)  =&gt; println!(\"The number is {number}\"),\n        Err(e) =&gt; println!(\"We ran into an error! {e:?}\"),\n    };\n}\nWe ran into an error! ParseIntError { kind: InvalidDigit }",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Handling Errors</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/error-handling.html#ux-for-errors",
    "href": "building-rust-based-r-pkgs/error-handling.html#ux-for-errors",
    "title": "31  Handling Errors",
    "section": "UX for Errors",
    "text": "UX for Errors\nThis is a philisophical conversation, really.\nI’m of the mind that, for vectorized functions, we do not give up on everything if an error has occured. Instead, return NULL or NA wherever an error may have occurred.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Handling Errors</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/error-handling.html#exercise",
    "href": "building-rust-based-r-pkgs/error-handling.html#exercise",
    "title": "31  Handling Errors",
    "section": "Exercise",
    "text": "Exercise\n\nHandle errors from encode():\n\nreturn Rstr::na() when there is an error\notherwise, return Rstr::from(res)\n\n\n\nSolution\n\n\nView hint\n\nPerform a match on the result of encode() e.g.\nlet res = encode(coord, length);\n\nmatch res {\n    Ok(gh) =&gt; todo!(),\n    Err(_) =&gt; todo!()\n}\n\n\n\nView solution\n\n#[extendr]\nfn gh_encode(x: Doubles, y: Doubles, length: usize) -&gt; Strings {\n    if length == 0 || length &gt; 12 {\n        throw_r_error(\"`length` must be between 1 and 12\");\n    }\n\n    x.into_iter()\n        .zip(y.into_iter())\n        .map(|(xi, yi)| {\n            let coord = Coord {\n                x: xi.inner(),\n                y: yi.inner(),\n            };\n            match encode(coord, length) {\n                Ok(res) =&gt; Rstr::from(res),\n                Err(_) =&gt; Rstr::na()\n            }\n        })\n        .collect::&lt;Strings&gt;()\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Handling Errors</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/na-handling.html#example",
    "href": "building-rust-based-r-pkgs/na-handling.html#example",
    "title": "32  Handle NAs gracefully",
    "section": "",
    "text": "let num_parsed = \"10\".parse::&lt;i32&gt;();\n\nmatch num_parsed {\n    Ok(num) =&gt; {\n        match num &gt; 10 {\n            true =&gt; println!(\"Parsed number is greater than 10!\"),\n            false =&gt; println!(\"Parsed number is less than or equal to 10\")\n        }\n    },\n    Err(e) =&gt; println!(\"Failed to parse number with error: {e:?}\")\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Handle NAs gracefully</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/na-handling.html#exercise",
    "href": "building-rust-based-r-pkgs/na-handling.html#exercise",
    "title": "32  Handle NAs gracefully",
    "section": "Exercise",
    "text": "Exercise\n\nCheck if either xi or yi is an NA (use xi.is_na()) and store in a variable is_missing\nMatch on is_missing:\n\nif true return an NA\notherwise attempt to use encode() and match on the Result\n\n\n\n\nView solution\n\n#[extendr]\nfn gh_encode(x: Doubles, y: Doubles, length: usize) -&gt; Strings {\n    if length == 0 || length &gt; 12 {\n        throw_r_error(\"`length` must be between 1 and 12\");\n    }\n\n    x.into_iter()\n        .zip(y.into_iter())\n        .map(|(xi, yi)| {\n            let is_missing = xi.is_na() || yi.is_na();\n\n            match is_missing {\n                true =&gt; Rstr::na(),\n                false =&gt; {\n                    let coord = Coord {\n                        x: xi.inner(),\n                        y: yi.inner(),\n                    };\n                    match encode(coord, length) {\n                        Ok(res) =&gt; Rstr::from(res),\n                        Err(_) =&gt; Rstr::na(),\n                    }\n                }\n            }\n        })\n        .collect::&lt;Strings&gt;()\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Handle NAs gracefully</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/enums.html",
    "href": "building-rust-based-r-pkgs/enums.html",
    "title": "33  Translating Enums",
    "section": "",
    "text": "Matching strings\nOur next objective is to find the directional neighbor of a geohash using the function geohash::neigbor(). It has the format:\nIn this case direction is an enum that is defined as\nUsing an enum as an argument is a natural thing to do when it can only take on a few values. In R, this would be akin to:\nUsing match.arg() lets us enumerate the possible values the argument can take on. An enum in Rust is a stricter and more formal way of doing this.\nThe natural inclination of an R programmer is to specify a vector of possible values the argument can take on.\nTranslating these to a Rust enum requires us to parse the string into an enum. There are essentially an infinite number of variants a single string can take on, so there must always be a fallback.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Translating Enums</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/enums.html#matching-strings",
    "href": "building-rust-based-r-pkgs/enums.html#matching-strings",
    "title": "33  Translating Enums",
    "section": "",
    "text": "A more modern approach would be to use {S7} to formalize an enum. See my blog post on this subject for more.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Translating Enums</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/enums.html#exercise",
    "href": "building-rust-based-r-pkgs/enums.html#exercise",
    "title": "33  Translating Enums",
    "section": "Exercise",
    "text": "Exercise\n\nCreate a function as_direction() that converts a String to a Direction\nOptionally, convert the String to lowercase using .to_lowercase() first for a more robust check\n\n\n\nView solution\n\nfn as_direction(direction: String) -&gt; Direction {\n    match direction.to_lowercase().as_str() {\n        \"n\" =&gt; Direction::N,\n        \"ne\" =&gt; Direction::NE,\n        \"e\" =&gt; Direction::E,\n        \"se\" =&gt; Direction::SE,\n        \"s\" =&gt; Direction::S,\n        \"sw\" =&gt; Direction::SW,\n        \"w\" =&gt; Direction::W,\n        \"nw\" =&gt; Direction::NW,\n        _ =&gt; throw_r_error(\"Invalid geohash neighbor direction\"),\n    }\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Translating Enums</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/enums.html#example",
    "href": "building-rust-based-r-pkgs/enums.html#example",
    "title": "33  Translating Enums",
    "section": "Example",
    "text": "Example\nReturning to the Shape example:\nenum Shape {\n    Triangle,\n    Square,\n    Pentagon,\n    Hexagon,\n}\nwe want to parse a String to a Shape we may want to write:\n\n\n\n\n\n\nCannot compile\n\n\n\nfn as_shape(x: String) -&gt; Shape {\n    match x {\n        \"triangle\" =&gt; Shape::Triangle,\n        \"square\" =&gt; Shape::Square,\n        \"pentagon\" =&gt; Shape::Pentagon,\n        \"hexagon\" =&gt; Shape::Hexagon,\n        _ =&gt; throw_r_error(\"Unrecognized shape provided\"),\n    }\n}\n\n\nThere’s an issue! Strings in Rust are wonky!",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Translating Enums</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/enums.html#cannot-compile",
    "href": "building-rust-based-r-pkgs/enums.html#cannot-compile",
    "title": "33  Translating Enums",
    "section": "Cannot compile",
    "text": "Cannot compile\nfn as_shape(x: String) -&gt; Shape {\n    match x {\n        \"triangle\" =&gt; Shape::Triangle,\n        \"square\" =&gt; Shape::Square,\n        \"pentagon\" =&gt; Shape::Pentagon,\n        \"hexagon\" =&gt; Shape::Hexagon,\n        _ =&gt; throw_r_error(\"Unrecognized shape provided\"),\n    }\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Translating Enums</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/enums.html#string-vs-str",
    "href": "building-rust-based-r-pkgs/enums.html#string-vs-str",
    "title": "33  Translating Enums",
    "section": "String vs &str",
    "text": "String vs &str\nI’ve tried to hide this for a while now! But strings in Rust are a bit weird.\nThe type String can be thought of as an owned container for a string. Whereas when we write a string like \"hello, world!\" this is creates a temporary reference to a value as a &str (note the &). Since the two are distinctly different types to Rust, they cannot be compared directly.\nInstead we must convert our String to a &str. We can do this using .as_str() method on a string.\nfn as_shape(x: String) -&gt; Shape {\n    match x.as_str() {\n        \"triangle\" =&gt; Shape::Triangle,\n        \"square\" =&gt; Shape::Square,\n        \"pentagon\" =&gt; Shape::Pentagon,\n        \"hexagon\" =&gt; Shape::Hexagon,\n        _ =&gt; throw_r_error(\"Unrecognized shape provided\"),\n    }\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Translating Enums</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/geohash-nb.html",
    "href": "building-rust-based-r-pkgs/geohash-nb.html",
    "title": "34  Geohash Neighbor",
    "section": "",
    "text": "Exercise\nWe now know how to take a string in R and convert it into an enum and what a &str is.\nWe’re going to begin building up a gh_neighbor() function which takes two arguments:\nand returns a geohash as a string. We’re going to create an R wrapper to this function.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Geohash Neighbor</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/geohash-nb.html#exercise",
    "href": "building-rust-based-r-pkgs/geohash-nb.html#exercise",
    "title": "34  Geohash Neighbor",
    "section": "",
    "text": "Create a new function gh_encode() which has two arguments: geohash: String, and direction: String and returns a String\nImport neighbor() from geohash\nUse as_direction() to process the direction arguments\nUse neighbor() to return the resultant geohash (you can unwrap for now)\n\nNote: borrow geohash as neighbor() expects a &str—i.e. neighbor(&geohash, ...)\n\n\n\n\nView solution\n\n#[extendr]\nfn gh_neighbor(geohash: String, direction: String) -&gt; String {\n    let dir = as_direction(direction);\n    neighbor(&geohash, dir).unwrap()\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Geohash Neighbor</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/vectorize-neighbor.html#exercise-1",
    "href": "building-rust-based-r-pkgs/vectorize-neighbor.html#exercise-1",
    "title": "35  Vectorize gh_neighbor()",
    "section": "",
    "text": "Change the argument geohash to take a character vector via geohash: Strings\nReturn a character vector using -&gt; Strings\nAdd the function to extendr_module! { }\nTest the function on new data in R\n\n\n\nView solution\n\n#[extendr]\nfn gh_neighbor(geohash: Strings, direction: String) -&gt; Strings {\n    let dir = as_direction(direction);\n    geohash\n        .into_iter()\n        .map(|gh| neighbor(&gh, dir).unwrap())\n        .collect::&lt;Strings&gt;()\n}\nIn R test your function with:\nn &lt;- 1000\nx &lt;- runif(n, -180, 180)\ny &lt;- runif(n, -90, 90)\n\ngeohashes &lt;- gh_encode(x, y, 8)\n\ngh_neighbor(geohashes, \"e\")",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Vectorize `gh_neighbor()`</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/vectorize-neighbor.html#exercise-2",
    "href": "building-rust-based-r-pkgs/vectorize-neighbor.html#exercise-2",
    "title": "35  Vectorize gh_neighbor()",
    "section": "Exercise 2",
    "text": "Exercise 2\nMake this function robust to errors by returning an NA when an error is encountered.\n\n\nView solution\n\n#[extendr]\nfn gh_neighbor(geohash: Strings, direction: String) -&gt; Strings {\n    let dir = as_direction(direction);\n    geohash\n        .into_iter()\n        .map(|gh| {\n            let nb = neighbor(&gh, dir);\n            match nb {\n                Ok(res) =&gt; Rstr::from(res),\n                Err(_) =&gt; Rstr::na(),\n            }\n        })\n        .collect::&lt;Strings&gt;()\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Vectorize `gh_neighbor()`</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/decode.html#data_frame-macro",
    "href": "building-rust-based-r-pkgs/decode.html#data_frame-macro",
    "title": "36  Decode a geohash",
    "section": "data_frame!() macro",
    "text": "data_frame!() macro\nA data.frame doesn’t have a type safe representation in extendr (at this point). Constructing them is a bit awkward too. To help with this, there is a data_frame!() macro. It is a thin wrapper to data.frame() in R.\nIt returns an Robj which is an opaque type. We can use this to create a data.frame from any wrapper-vector compatible types. For example\n\nExample\n#[extendr]\nfn xyz(x: Doubles, y: Doubles, z: Doubles) -&gt; Robj {\n    data_frame!(x = x, y = y, z = z)\n}\nxyz(rnorm(5), rnorm(5), rnorm(5))\n#&gt;            x          y          z\n#&gt; 1 -0.2688881  0.2349470  1.3468095\n#&gt; 2 -1.1228202  2.3786258  0.2405386\n#&gt; 3  1.6705694  1.4699630 -0.1370552\n#&gt; 4  3.1485605  0.6131987  0.9025077\n#&gt; 5  0.1374142 -1.5969236 -0.6165083",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Decode a geohash</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/decode.html#whats-a-data.frame",
    "href": "building-rust-based-r-pkgs/decode.html#whats-a-data.frame",
    "title": "36  Decode a geohash",
    "section": "",
    "text": "It is not vector nor row, But list, in constume, pretending to be square.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Decode a geohash</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/decode.html#whats-data.frame",
    "href": "building-rust-based-r-pkgs/decode.html#whats-data.frame",
    "title": "36  Decode a geohash",
    "section": "",
    "text": "It is not vector nor row, but list, in constume, pretending to be square.\n\n\n\nvectors of equal length\ncolumn names\nrow names\nthe data.frame class",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Decode a geohash</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/decode.html#exercise",
    "href": "building-rust-based-r-pkgs/decode.html#exercise",
    "title": "36  Decode a geohash",
    "section": "Exercise",
    "text": "Exercise\nCreate a new function called gh_decode() which has one argument geohash: String and returns a data.frame as an Robj.\n\nImport decode() from geohash\nDecode the input geohash and unwrap the result.\n\nBonus points for using destructured assignment of the tuple\n\nCreate a data.frame with 4 columns x, y, x_err, and y_err using data_frame!()\nAdd the function to extendr_module! {}\nRun rextendr::document() to update the package\nTest the function locally on the geohash \"q8nb00j\"\n\n\nSolution\n\n\nView solution\n\n#[extendr]\nfn gh_decode(geohash: String) -&gt; Robj {\n    let (coord, x_err, y_err) = decode(&geohash).unwrap();\n    data_frame!(x = coord.x, y = coord.y, x_err = x_err, y_err = y_err)\n}",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Decode a geohash</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/types.html#integers",
    "href": "intro-to-rust-for-r-devs/types.html#integers",
    "title": "3  Basic Types",
    "section": "",
    "text": "Signed Integers: i8, i16, i32, i64, i128\nUnsigned Integers: u8, u16, u32, u64, u128\n\n\n\n\n\n\n\nIn R, an integer vector is comprised of i32 values.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Types</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/types.html#floating-point",
    "href": "intro-to-rust-for-r-devs/types.html#floating-point",
    "title": "3  Basic Types",
    "section": "Floating point",
    "text": "Floating point\nIn many cases where we need to do math we will use a floating point number. Floating points are signed and allow for decimal values.\nThere are two types: f32 and f64.\n\n\n\n\n\n\nIn R, a double vector is comprised of f64 values.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Types</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/types.html#strong-typing",
    "href": "intro-to-rust-for-r-devs/types.html#strong-typing",
    "title": "3  Basic Types",
    "section": "Strong typing",
    "text": "Strong typing\nRust will infer a value’s type exceptionally well! However, we may want to specify the type manually as well. We can do this 2 primary ways:\n\nIn assignment using : for example let x: f64 = 10;\nOr by specifying the suffix e.g. 10f64 or 10_i32\n\n\n\n\n\n\n\nYou can use _ as a visual separator when specifying numbers in Rust. The following are all identical values:\nlet x: i32 = 1000;\nlet x = 1000i32;\nlet x = 1_000_i32;",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Types</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/types.html#type-casting",
    "href": "intro-to-rust-for-r-devs/types.html#type-casting",
    "title": "3  Basic Types",
    "section": "Type casting",
    "text": "Type casting\nIn Rust, math expressions can only be performed between like-types. You cannot add 2.0 + 3_f64. To accomplish this we must cast to the same types.\nPrimitive types can be cast into one another using the as keyword. To add an f64 to an i32 we should ensure they’re the same type.\nfn add2(x: f64, y: i32) -&gt; f64 {\n   x + y as f64\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Types</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/types.html#unit-type",
    "href": "intro-to-rust-for-r-devs/types.html#unit-type",
    "title": "3  Basic Types",
    "section": "Unit type",
    "text": "Unit type\nIn Rust there is no concept of NULL. Instead there is the unit type which is represented as ().\n\n\nThe unit type is technically a tuple without any fields. If the internet is to be believed it is called “unit” becaue it can only have one value and is related to the “singleton” or unit set in set theory.\nFunctions that do not return anything technically return ().",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Types</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/types.html#exercise",
    "href": "intro-to-rust-for-r-devs/types.html#exercise",
    "title": "3  Basic Types",
    "section": "Exercise",
    "text": "Exercise\nModify src/main.rs to add two or more incompatible types.\n\nDefine a variable x to be an f64 value\nDefine y to be an i32 value\nAdd them up and store them in the variable z\nUse println!() to print the value of z\n\n\nSolution\n\n\nView solution\n\nfn main() {\n    let x = 3.14;\n    let y = 47_i32;\n    let z = x + y as f64;\n    println!(\" The vlaue of z is {z}\");\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Types</span>"
    ]
  }
]