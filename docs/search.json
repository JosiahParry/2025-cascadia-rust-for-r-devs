[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Rust for R Developers",
    "section": "",
    "text": "Get set up\nBefore we can start, we need to get our house in order. We need to install:",
    "crumbs": [
      "Get set up"
    ]
  },
  {
    "objectID": "index.html#setting-up",
    "href": "index.html#setting-up",
    "title": "Rust for R Developers",
    "section": "",
    "text": "R 4.5\nPositron\nRust\nRust analyzer VS Code extension\nEven Better TOML VS Code extension\n{rextendr}",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Get set up</span>"
    ]
  },
  {
    "objectID": "index.html#install-r",
    "href": "index.html#install-r",
    "title": "Rust for R Developers",
    "section": "Install R",
    "text": "Install R\nPlease install R version 4.5 to ensure that everyone developing has the same experience.\n\n\n\n\n\n\nI recommend using rig to install a new version of R for you.\nInstallation instructions for rig here",
    "crumbs": [
      "Get set up"
    ]
  },
  {
    "objectID": "index.html#install-positron",
    "href": "index.html#install-positron",
    "title": "Rust for R Developers",
    "section": "Install Positron",
    "text": "Install Positron\nDownload the appropriate Positron installer from the downloads page.\nOpen the extensions pane (or press shift + cmd + x).\n\nsearch for rust analyzer and install\nsearch for even better toml and install",
    "crumbs": [
      "Get set up"
    ]
  },
  {
    "objectID": "index.html#install-rust",
    "href": "index.html#install-rust",
    "title": "Rust for R Developers",
    "section": "Install rust",
    "text": "Install rust\nTo install Rust, please use rustup. If you use a system installation via brew, apt, dnf, etc you will likely run into issues. I will be able to help debug these.\nFor installing Rust on Mac / Unix / Linux please run:\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\nWindows\nIf using Windows download the appropriate installer. Then, once your installation is complete, from your command prompt run:\nrustup target add x86_64-pc-windows-gnu\nThis is a compilation target that is required for building extendr packages on Windows.",
    "crumbs": [
      "Get set up"
    ]
  },
  {
    "objectID": "index.html#install-rextendr",
    "href": "index.html#install-rextendr",
    "title": "Rust for R Developers",
    "section": "Install {rextendr}",
    "text": "Install {rextendr}\nWe will be using the rextendr package to build Rust powerd R-packages.\n\n\n\n\n\n\nOther R package dependencies\n\n\n\nWe also will be relying on other packages in the R ecosytem to make developing easier. Please install:\n\ndevtools\nusethis\n\ninstall.packages(c(\"devtools\", \"usethis\"))\n\n\nInstall the package using:\nif (!requireNamespace(\"remotes\")) {\n    install.packages(\"remotes\")\n}\n\nremotes::install_github(\"extendr/rextendr\")\nOnce rextendr is installed, run the below command. You are good to go if:\n\n✅ cargo version is printed (should be 1.80 or greater)\n✅ rustup has a recent version printed\n✅ You have an active default toolchain\n\n\n\n\n\n\n\nIf you’re using windows ensure that x86_64-pc-windows-gnu is your default target. See the above command if it is not.\nR does not support packages compiled with Microsoft Visual C++ (MSVC) so this is required.\n\n\n\n\nrextendr::rust_sitrep()\n\nRust infrastructure sitrep:\n✔ \"rustup\": 1.28.2 (e4f3ad6f8 2025-04-28)\n✔ \"cargo\": 1.85.1 (d73d2caf9 2024-12-31)\nℹ host: aarch64-apple-darwin\nℹ toolchains: stable-aarch64-apple-darwin (active, default),\n  nightly-aarch64-apple-darwin, 1.65.0-aarch64-apple-darwin,\n  1.72.1-aarch64-apple-darwin, 1.74.1-aarch64-apple-darwin,\n  1.75.0-aarch64-apple-darwin, 1.76.0-aarch64-apple-darwin, and\n  1.80.1-aarch64-apple-darwin\n! One of these toolchains should be default: stable-aarch64-apple-darwin\n  (active, default), nightly-aarch64-apple-darwin, 1.65.0-aarch64-apple-darwin,\n  1.72.1-aarch64-apple-darwin, 1.74.1-aarch64-apple-darwin,\n  1.75.0-aarch64-apple-darwin, 1.76.0-aarch64-apple-darwin, and\n  1.80.1-aarch64-apple-darwin\nℹ Run e.g. `rustup default stable-aarch64-apple-darwin (active, default)`",
    "crumbs": [
      "Get set up"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/index.html",
    "href": "intro-to-rust-for-r-devs/index.html",
    "title": "Intro to Rust for R Developers",
    "section": "",
    "text": "Timeline\nobjective go from zero to hero asap writing vectorized code as fast as posisble\nWe’ve got 3 hours to cover a lot of ground!",
    "crumbs": [
      "Intro to Rust for R Developers"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/index.html#timeline",
    "href": "intro-to-rust-for-r-devs/index.html#timeline",
    "title": "Intro to Rust for R Developers",
    "section": "",
    "text": "What is rust\nHello, World!\nPrimitive types, logical/boolean operators, and control flow\nCreating Functions\nArrays & vectors\nFor loops\nMutability\nIterators\nReferences and Slices\nStructs\n\n\n\n\nStart\nDescription",
    "crumbs": [
      "Intro to Rust for R Developers"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/why-rust.html",
    "href": "intro-to-rust-for-r-devs/why-rust.html",
    "title": "2  Why Rust?",
    "section": "",
    "text": "Reasoning\nRust is a programming language that’s fast, safe, and surprisingly friendly to use. Unlike R, which runs code line by line, Rust turns your code into a standalone program that runs directly on your computer. This makes it much faster and more efficient, similar to languages like C or C++. But where those languages can be hard to use and easy to break, Rust was built to be safer and more helpful.\nRust is especially good at preventing bugs related to memory and parallel code — the kind that can be really hard to track down in other languages. And it comes with tools and error messages that make writing and fixing code feel more approachable, even if you’re new to systems programming. Many R users find Rust refreshing: it’s strict, but in a way that teaches you better habits.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Why Rust?</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/why-rust.html#tldr",
    "href": "intro-to-rust-for-r-devs/why-rust.html#tldr",
    "title": "2  Why Rust?",
    "section": "TL;DR",
    "text": "TL;DR\n\nR is interpreted. Code runs line by line.\nR (and Python) are built on C.\nC is compiled — it builds a binary that runs directly on your machine.\nRust is also compiled, like C, C++, Go, Java, and Fortran.\nThese languages are “close to the metal” — fast, efficient, and powerful.\nRust matches C++ in speed, but with some key advantages:\n\nMemory safety without a garbage collector (unlike Go), thanks to the borrow checker.\nFearless concurrency — Rust makes parallelism safer and easier.\nA great developer experience:\n\nHelpful, friendly compiler errors (Tidyverse-level DX).\nModern tooling (cargo, rustdoc, rustfmt, rust-analyzer, etc.).\n\n\nRust is easy to get started with and rewards best practices.\n\nWe won’t go deep into memory safety or concurrency today\n\nRust uses errors as data, unlike R and C++, Rust does not support exceptions",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Why Rust?</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/hello-world.html",
    "href": "intro-to-rust-for-r-devs/hello-world.html",
    "title": "3  Hello, World!",
    "section": "",
    "text": "Crate anatomy\nRust uses a tool called cargo for building, checking, and managing dependencies.\nTo create a new Rust crate, use cargo new name-of-crate.\nTwo types of crates: binary, library.\nBinary crates are standalone applications like command line tools, or things that run once—simiar to a script that you run with Rscript main.R",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Hello, World!</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/hello-world.html#crate-anatomy",
    "href": "intro-to-rust-for-r-devs/hello-world.html#crate-anatomy",
    "title": "3  Hello, World!",
    "section": "",
    "text": "This first workshop we will work only with a binary crate. We will create a library in the second half of the day.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Hello, World!</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/hello-world.html#crate-anatomy-1",
    "href": "intro-to-rust-for-r-devs/hello-world.html#crate-anatomy-1",
    "title": "3  Hello, World!",
    "section": "Crate anatomy",
    "text": "Crate anatomy\nA new crate looks like this:\nintro-to-rust/\n├── Cargo.toml      # Metadata & dependencies (like DESCRIPTION)\n├── Cargo.lock      # Dependency versions (like renv.lock)\n└── src/\n    └── main.rs     # Entry point — like main.R",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Hello, World!</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/hello-world.html#main.rs",
    "href": "intro-to-rust-for-r-devs/hello-world.html#main.rs",
    "title": "3  Hello, World!",
    "section": "main.rs",
    "text": "main.rs\nWhen you create a new rust binary the file src/main.rs is prepopulated with:\n\n\n\n\n\n\nsrc/main.rs defines what is executed when your binary is run.\n\n\n\nfn main() {\n    println!(\"Hello, world!\");\n}\nThere are a few things going on in here:\n\nFunctions are declared using the fn keyword\nThe main() function is the entrypoint of the program (and required)\nBlocks of code are delimted using curly braces (like R & C)\nStatements end with ;\nprintln!() is a macro (notice the !) which is used to print to stdout\n\n\n\nWhen a program writes to the console it does so through file connections called standard output (stdout) and standard error (stderr).\nWhen we print a message with print() or message() in R, we print to stdout. When we make a warning or error using stop() or warning() in R, that is writing to stderr.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Hello, World!</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/hello-world.html#println",
    "href": "intro-to-rust-for-r-devs/hello-world.html#println",
    "title": "3  Hello, World!",
    "section": "println!()",
    "text": "println!()\n\nMacros have a !, like println!().\nThink of it like print() in R, but explicit.\nIt supports format strings:\n\nlet name = \"Josiah\";\nprintln!(\"Hello, {}!\", name);  // -&gt; Hello, Josiah!",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Hello, World!</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/hello-world.html#exercise",
    "href": "intro-to-rust-for-r-devs/hello-world.html#exercise",
    "title": "3  Hello, World!",
    "section": "Exercise",
    "text": "Exercise\n\nIn your terminal, create a new rust crate called intro-to-rust\nOpen the new rust crate in Positron\nRun the hello world program\nCreate variable called name with your name\nPrint Hello, {name}! using println!()\n\n\nSolution\n\n\nView solution\n\nIn src/main.rs\nfn main() {\n    let name = \"Josiah\";\n    println!(\"Hello, {name}!\");\n}\nTo run it navigate to your terminal and then run cargo run.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Hello, World!</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/types.html",
    "href": "intro-to-rust-for-r-devs/types.html",
    "title": "4  Basic Types",
    "section": "",
    "text": "much of what we do in rust are done on individual values (scalars)\nr work is typically done on vectors (collections of like values) and most operations are vectorized\nin rust we have to perform the vectorized ops our self\ni32\ni64 (exists but is incompatible with R, generally don’t need it)\nusize\nf64\nf32 (exists don’t we don’t use it)\ntype inference: e.g. let x = 10; infers i32\nexplicit typing e.g. let x = 10usize or let x: usize = 10\n\n() unit type - literally nothing",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic Types</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/fizz-buzz.html",
    "href": "intro-to-rust-for-r-devs/fizz-buzz.html",
    "title": "5  Control Flow",
    "section": "",
    "text": "Numeric operators",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/fizz-buzz.html#numeric-operators",
    "href": "intro-to-rust-for-r-devs/fizz-buzz.html#numeric-operators",
    "title": "5  Control Flow",
    "section": "",
    "text": "+ addition\n- subtraction\n/ division\n^ exponentiation actually, ^ is a logical operator for XOR\n% remainder",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/fizz-buzz.html#logical-operators",
    "href": "intro-to-rust-for-r-devs/fizz-buzz.html#logical-operators",
    "title": "5  Control Flow",
    "section": "Logical Operators:",
    "text": "Logical Operators:\nLogical operators are quite similar to R. The difference is that these operations are not vectorised. Furthermore, in Rust, a logical is called bool for boolean.s\n\n== check equality\n!= check inequality\n! negate a logical value\n&& logical AND comparison\n|| logical OR comparison",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/fizz-buzz.html#control-flow",
    "href": "intro-to-rust-for-r-devs/fizz-buzz.html#control-flow",
    "title": "5  Control Flow",
    "section": "Control flow",
    "text": "Control flow\nRust uses if, else, and else if statements just like R. Where each branch is delimted by curly braces.\n\n\n\n\n\n\nEach branch of the if statement must return the same type. For this portion of the workshop, be sure to terminate each statement inside of the if statement so that nothing is returned.\n\n\n\nif x == y {\n  // do something\n} else {\n  // do something else\n}\nThe key difference is that the use of parentheses is not necessary for the conditional statement.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/fizz-buzz.html#exercise",
    "href": "intro-to-rust-for-r-devs/fizz-buzz.html#exercise",
    "title": "5  Control Flow",
    "section": "Exercise",
    "text": "Exercise\nThis exercise you will create the famous FizzBuzz program.\nFor this, create a variable i. The rules are:\n\nwhen i is a multiple of 3, print Fizz\nwhen i is a multiple of 5, print Buzz\nwhen i is a multiple of both 3 and 5, print FizzBuzz\n\n\nSolution\n\n\nView solution\n\nfn main() {\n    // let i = 15; // FizzBuzz\n    // let i = 3; // Fizz\n    // let i = 5; // Buzz\n    let i = 47; // Nothing\n    if (i % 3 == 0) && (i % 5 == 0) {\n        println!(\"FizzBuzz\");\n    } else if i % 3 == 0 {\n        println!(\"Fizz\");\n    } else if i % 5 == 0 {\n        println!(\"Buzz\");\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Control Flow</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/collections.html",
    "href": "intro-to-rust-for-r-devs/collections.html",
    "title": "6  Arrays and Vectors",
    "section": "",
    "text": "Arrays\nArrays in Rust are fixed in size and hold values of the same type. Since the size is known ahead of time, it makes them fast but inflexible.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Arrays and Vectors</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/collections.html#arrays",
    "href": "intro-to-rust-for-r-devs/collections.html#arrays",
    "title": "6  Arrays and Vectors",
    "section": "",
    "text": "fn main() {\n    let arr = [10, 20, 30, 40];\n    println!(\"Array: {:?}\", arr);\n}\n\n\n\n\n\n\nThe {:?} syntax is used for a Debug representation of a variable. Using {} is used for Displaying data.\nMore often than not, using {:?} will be your best option.\n\n\n\n\nArrays use square brackets: [1, 2, 3]\nTheir size is known at compile time.\nYou can’t add or remove elements.\nMostly used when performance is critical and size is known.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Arrays and Vectors</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/collections.html#vectors",
    "href": "intro-to-rust-for-r-devs/collections.html#vectors",
    "title": "6  Arrays and Vectors",
    "section": "Vectors",
    "text": "Vectors\nVectors are like growable arrays. They live on the heap and are much more common in everyday Rust code. We’ll explore how to modify them later, but for now, we can define them with values known at the start.\nfn main() {\n    let v = vec![1, 2, 3, 4, 5];\n    println!(\"Vector: {:?}\", v);\n}\n\nCreate vectors using vec![]\nYou don’t need mut if you’re not changing them.\nLike arrays, all values must be the same type.\n\nIn R, most things are vectorized. In Rust, we often iterate over collections to work with them.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Arrays and Vectors</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/collections.html#exercise",
    "href": "intro-to-rust-for-r-devs/collections.html#exercise",
    "title": "6  Arrays and Vectors",
    "section": "Exercise",
    "text": "Exercise\n\nCreate an array of 4 integers and print it.\nCreate a vector with 5 numbers and print it using {:?}.\nCompare the length of the array and the vector.\n\n\nSolution\n\n\nView solution\n\nfn main() {\n    let arr = [1, 2, 3, 4];\n    println!(\"Array: {:?}\", arr);\n\n    let v = vec![10, 20, 30, 40, 50];\n    println!(\"Vector: {:?}\", v);\n}\n\n\nNOTES:\nTODO:\nadd a bit on .len() and .is_empty()",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Arrays and Vectors</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/for-loops.html",
    "href": "intro-to-rust-for-r-devs/for-loops.html",
    "title": "7  for-loops",
    "section": "",
    "text": "for loop syntax\nIn Rust, for loops are the easiest way to go over each item in a vector or array.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`for`-loops</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/for-loops.html#for-loop-syntax",
    "href": "intro-to-rust-for-r-devs/for-loops.html#for-loop-syntax",
    "title": "7  for-loops",
    "section": "",
    "text": "for value in collection {\n    // do something with value\n}\n\nfn main() {\n    let nums = vec![1, 2, 3];\n    for n in nums {\n        println!(\"n is: {}\", n);\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`for`-loops</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/for-loops.html#scope",
    "href": "intro-to-rust-for-r-devs/for-loops.html#scope",
    "title": "7  for-loops",
    "section": "Scope",
    "text": "Scope\n\nValues outside of the for loop are accessible inside of it.\nValues created inside of the for loop cannot be accessed outside of it.\n\nExample: outer value used inside loop\nfn main() {\n    let greeting = \"Hi\";\n    let names = vec![\"Alice\", \"Bob\"];\n\n    for name in names {\n        println!(\"{} {}!\", greeting, name);\n    }\n}\nExample: inner value not usable outside loop\n\nThis does not compile!\n\nfn main() {\n    let numbers = vec![1, 2, 3];\n\n    for n in numbers {\n        let doubled = n * 2;\n        println!(\"{} doubled is {}\", n, doubled);\n    }\n\n    // println!(\"Last doubled: {}\", doubled); // ❌ `doubled` doesn't exist here\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`for`-loops</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/for-loops.html#exercise",
    "href": "intro-to-rust-for-r-devs/for-loops.html#exercise",
    "title": "7  for-loops",
    "section": "Exercise",
    "text": "Exercise\nUsing a vector of integers, write a loop that prints:\n\n“Fizz” if divisible by 3\n“Buzz” if divisible by 5\n“FizzBuzz” if divisible by both\nThe number otherwise\n\nUse this vector: vec![1, 2, 3, 4, 5, 15]\n\nSolution\n\n\nView solution\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5, 15];\n\n    for n in nums {\n        if n % 15 == 0 {\n            println!(\"FizzBuzz\");\n        } else if n % 3 == 0 {\n            println!(\"Fizz\");\n        } else if n % 5 == 0 {\n            println!(\"Buzz\");\n        } else {\n            println!(\"{}\", n);\n        }\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`for`-loops</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/mutability.html",
    "href": "intro-to-rust-for-r-devs/mutability.html",
    "title": "8  Mutability",
    "section": "",
    "text": "Exercise\nIn Rust, variables are immutable by default. This means once a value is assigned to a variable, it cannot be changed. To make a variable mutable, you must explicitly use the mut keyword.\nBy requiring mut, the compiler ensures that accidental mutations are caught at compile time.\nHere’s an example revisiting our loop from earlier:",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mutability</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/mutability.html#exercise",
    "href": "intro-to-rust-for-r-devs/mutability.html#exercise",
    "title": "8  Mutability",
    "section": "",
    "text": "Create a vector of 5 or more f64 values (Vec&lt;f64&gt;)\nUse a for loop to calculate the mean of the vector\nPrint the result\n\n\n\n\n\n\n\nWe’ve been working only with integers. To create a float (number with decimals) use 0.0 or specify the type manually e.g. 0f64.\n\n\n\n\nSolution\n\n\nView solution\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0];\n\n    let n = x.len() as f64;\n    let mut total = 0.0;\n\n    for xi in x {\n        total += xi;\n    }\n\n    println!(\"The mean is: {}\", total / n);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mutability</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/mutable-vectors.html",
    "href": "intro-to-rust-for-r-devs/mutable-vectors.html",
    "title": "9  Mutable Vectors",
    "section": "",
    "text": "Creating empty vectors\nIn Rust, vectors (Vec&lt;T&gt;) are growable arrays. To modify a vector after creating it, the vector itself must be declared as mut.\nYou can create an empty vector and let Rust infer the type based on usage:",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mutable Vectors</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/mutable-vectors.html#exercise",
    "href": "intro-to-rust-for-r-devs/mutable-vectors.html#exercise",
    "title": "9  Mutable Vectors",
    "section": "Exercise",
    "text": "Exercise\n\nCreate an empty vector\nAppend the values 1.0, 2.0, and 3.0 using .push()\nClear the vector to make it empty\nLastly, extend it with another vector e.g. [4.0, 5.0]\nSort the vector\nPrint the final result.\n\n\nSolution\n\n\nView solution\n\nfn main() {\n    let mut x = Vec::new();\n    x.push(1.0);\n    x.push(2.0);\n    x.push(3.0);\n    x.clear();\n    x.extend(vec![4.0, 5.0]);\n    println!(\"{:?}\", x);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Mutable Vectors</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/is-odd.html",
    "href": "intro-to-rust-for-r-devs/is-odd.html",
    "title": "10  Functions",
    "section": "",
    "text": "Example\nIdentifying if a number is odd or even isn’t always so easy!\nFirst define a function called is_even() that takes an i32 (integer) and returns a bool.\nWe can use our already defined function inside of another:",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/is-odd.html#example",
    "href": "intro-to-rust-for-r-devs/is-odd.html#example",
    "title": "10  Functions",
    "section": "",
    "text": "is-odd npm\n\n\n\nfn is_even(x: i32) -&gt; bool {\n    x % 2 == 0\n}\n\nfn is_odd(x: i32) -&gt; bool {\n    !is_even(x)\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/is-odd.html#exercise",
    "href": "intro-to-rust-for-r-devs/is-odd.html#exercise",
    "title": "10  Functions",
    "section": "Exercise",
    "text": "Exercise\nCreate a function called mean() that calculates the mean of a Vec&lt;f64&gt;.\n\nIn main(), create a vector x with 5 or more f64 values.\nCall mean(x) and print the result.\n\n\n\n\n\n\n\nUse x.len() to get the length and as f64 to convert it to a float.\n\n\n\n\nSolution\n\n\nView solution\n\nfn mean(x: Vec&lt;f64&gt;) -&gt; f64 {\n    let mut total = 0.0;\n    let n = x.len();\n    for xi in x {\n        total += xi;\n    }\n    total / n as f64\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let result = mean(x);\n    println!(\"Mean is: {}\", result);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/references-slices.html",
    "href": "intro-to-rust-for-r-devs/references-slices.html",
    "title": "11  Ownership",
    "section": "",
    "text": "Moves\nRust enforces ownership at compile time. This ensures memory safety, but it means variables can only be used once—unless they’re borrowed.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/references-slices.html#moves",
    "href": "intro-to-rust-for-r-devs/references-slices.html#moves",
    "title": "11  Ownership",
    "section": "",
    "text": "fn main() {\n    let x = vec![1.0, 2.0, 3.0];\n    let y = x; // 👈 ownership moved\n    println!(\"{:?}\", x); // ❌ error: value used after move\n}\n\nOwnership of x was moved to y\nAfter a move, the original variable (x) can’t be used",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/references-slices.html#borrowing",
    "href": "intro-to-rust-for-r-devs/references-slices.html#borrowing",
    "title": "11  Ownership",
    "section": "Borrowing",
    "text": "Borrowing\nfn main() {\n    let x = vec![1.0, 2.0, 3.0];\n    let avg = mean(&x); // 👈 borrowing `x`\n    println!(\"x is still usable: {:?}\", x);\n}\n\nBorrowing uses & to pass by reference\nYou can borrow a value as many times as you want (immutably)\nYou can’t mutate or move them while borrowed\n\n\n\n\n\n\n\n“When in doubt, clone it out!”\n\n\n\n\n.clone() makes a full copy of a value—useful when you need to keep ownership",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/references-slices.html#exercise-1",
    "href": "intro-to-rust-for-r-devs/references-slices.html#exercise-1",
    "title": "11  Ownership",
    "section": "Exercise 1",
    "text": "Exercise 1\nRewrite the mean() function to accept a reference to a Vec&lt;f64&gt; instead of taking ownership. Then call it with a borrowed vector.\n\nSolution\n\n\nView solution\n\nfn mean(x: &Vec&lt;f64&gt;) -&gt; f64 {\n    let mut total = 0.0;\n    for xi in x {\n        total += xi;\n    }\n    total / x.len() as f64\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/references-slices.html#slices",
    "href": "intro-to-rust-for-r-devs/references-slices.html#slices",
    "title": "11  Ownership",
    "section": "Slices",
    "text": "Slices\n\nA slice is a borrowed section of a collection\nAlways a reference: &[T]\nHas known length with .len()\nPreferred when you don’t need the full container\n\nlet values = vec![10.0, 20.0, 30.0];\nlet avg = mean(&values); // full slice\nlet avg = mean(&values[0..3]) // the first 3 elements\n\n\n\n\n\n\nWe won’t cover the [..] syntax but you should think it similar to R! It uses a range. A range takes the format of from..to where to is uninclusive. So 0..3 would be indices 0, 1, and 2!\n\n\n\n\nSlices are lighter-weight than borrowing a full vector\nIn general: prefer slices → references → moves",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/references-slices.html#exercise-2",
    "href": "intro-to-rust-for-r-devs/references-slices.html#exercise-2",
    "title": "11  Ownership",
    "section": "Exercise 2",
    "text": "Exercise 2\n\nRewrite mean() to accept a slice (&[f64]) instead of a Vec&lt;f64&gt; reference.\nTry using mean() on a subset of values.\n\n\nSolution\n\n\nView solution\n\nfn mean(x: &[f64]) -&gt; f64 {\n    let mut total = 0.0;\n    for xi in x {\n        total += xi;\n    }\n    total / x.len() as f64\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Ownership</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iterators.html",
    "href": "intro-to-rust-for-r-devs/iterators.html",
    "title": "12  Iterators",
    "section": "",
    "text": "Consuming vs. Borrowing\nIterators are values that produce a sequence of items, one at a time. They can be created from collections like vectors, arrays, and ranges.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iterators.html#consuming-vs.-borrowing",
    "href": "intro-to-rust-for-r-devs/iterators.html#consuming-vs.-borrowing",
    "title": "12  Iterators",
    "section": "",
    "text": ".into_iter() consumes the original value, transferring ownership.\n.iter() borrows the collection, producing references to each item.\nA for loop uses .into_iter() under the hood.\n\nfn main() {\n    let nums = vec![3, 6, 9];\n\n    for n in nums.into_iter() {\n        println!(\"Value: {}\", n);\n    }\n    // nums no longer available here ❌\n}\nfn main() {\n    let nums = vec![3, 6, 9];\n\n    for n in nums.iter() {\n        println!(\"Reference to value: {}\", n);\n    }\n    // nums is still usable ✅\n    println!(\"nums: {:?}\", nums);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iterators.html#basic-iterator-methods",
    "href": "intro-to-rust-for-r-devs/iterators.html#basic-iterator-methods",
    "title": "12  Iterators",
    "section": "Basic Iterator Methods",
    "text": "Basic Iterator Methods\nOnce you have an iterator, you can use built-in methods:\n\n.sum() — Add all the values together.\n.min() — Find the smallest value.\n.max() — Find the largest value.\n.enumerate() — Pairs each value with its index.\n\nfn main() {\n    let nums = vec![2, 4, 8];\n    let total: i32 = nums.iter().sum();\n    println!(\"Sum is: {}\", total);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iterators.html#exercise-1",
    "href": "intro-to-rust-for-r-devs/iterators.html#exercise-1",
    "title": "12  Iterators",
    "section": "Exercise 1",
    "text": "Exercise 1\n\nModify the mean() function to calculate the mean using .iter()\nCreate a vector of 5 or more f64 values\nCalculate the mean and print the result\n\n\nSolution\n\n\nView solution\n\nfn mean(x: &[f64]) -&gt; f64 {\n    let total: f64 = x.iter().sum();\n    total / x.len() as f64\n}\n\nfn main() {\n    let nums = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    println!(\"Mean is: {}\", mean(&nums));\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iterators.html#exercise-2",
    "href": "intro-to-rust-for-r-devs/iterators.html#exercise-2",
    "title": "12  Iterators",
    "section": "Exercise 2",
    "text": "Exercise 2\n\nPrint the index and value for each item in a vector for only even values\n\n\nSolution\n\n\nView solution\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5, 6];\n\n    for (i, n) in nums.iter().enumerate() {\n        if n % 2 == 0 {\n            println!(\"Index {i}: {n} is even\");\n        }\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iter-map.html",
    "href": "intro-to-rust-for-r-devs/iter-map.html",
    "title": "13  Mapping over Iterators",
    "section": "",
    "text": "Mapping over iterators",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Mapping over Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iter-map.html#mapping-over-iterators",
    "href": "intro-to-rust-for-r-devs/iter-map.html#mapping-over-iterators",
    "title": "13  Mapping over Iterators",
    "section": "",
    "text": ".map() transforms each item of an iterator by applying a closure (anonymous function)\nClosures are small functions you can define inline, e.g. |x| x + 1\nakin to purrr::map(x, ~ .x + 1) or .purrr::map(x, \\(.x) .x + 1)\nmapping only modifies the iterator\nwe need to collect() the values into another container if we want them\n\n\nExample\nTODO!",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Mapping over Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iter-map.html#collecting-iterators",
    "href": "intro-to-rust-for-r-devs/iter-map.html#collecting-iterators",
    "title": "13  Mapping over Iterators",
    "section": "Collecting iterators",
    "text": "Collecting iterators\n\n.collect() gathers the results of an iterator into a collection (like a vector)\nwe need to specify the type of what we’re collecting into.\nin our case we’re always going to collect into a vector\ntwo ways of specifying\n\nwe can specify the resultant type in the assignment with let x: Vec&lt;i32&gt; but this is not as flexible to changing code\nTurbofish ::&lt;Type&gt;() is used to explicitly specify types when needed\n\nits a bit more awkward at first, but it is more flexible and doesn’t require modification whenever the inner type changes\nadditionall we can use rust’s iference using _\n\n\n\n\nExamples\n\n\n\n\n\n\nExplicit typing\nfn main() {\n    let nums = vec![1, 2, 3];\n\n    // Add 1 to each element\n    let incremented: Vec&lt;_&gt; = nums.iter()\n        .map(|x| x + 1)\n        .collect();\n\n    println!(\"{:?}\", incremented);\n}\n\n\nInference w/ turbofish\nfn main() {\n    let nums = vec![1, 2, 3];\n\n    // Add 1 to each element\n    let incremented = nums.iter()\n        .map(|x| x + 1)\n        .collect::&lt;Vec&lt;_&gt;&gt;();\n\n    println!(\"{:?}\", incremented);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Mapping over Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iter-map.html#exercise-1",
    "href": "intro-to-rust-for-r-devs/iter-map.html#exercise-1",
    "title": "13  Mapping over Iterators",
    "section": "Exercise 1",
    "text": "Exercise 1\nCalculate the variance of a slice of f64 values.\n\\[\n\\text{variance} = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})^2}{n - 1}\n\\]\n\nCreate a function variance() that:\n\nUses .map() to calculate squared differences from the mean\nUses .sum() to add them up\nDivides by n - 1\n\n\n\n\n\n\n\n\n\nUse .powi(2) to square values.\nUse your previously defined mean() function inside variance().\n\n\n\n\n\n\nView hint\n\nfn variance(x: &[f64]) -&gt; f64 {\n    let n = x.len() as f64;\n    let avg = mean(x);\n    let sq_diffs: f64 = x\n        .iter()\n        .map(|xi| ___ )  // squared difference here\n        .__();           // sum method here\n\n    sq_diffs / (n - 1.0)\n}\n\n\nSolution\n\n\nView solution\n\nfn variance(x: &[f64]) -&gt; f64 {\n    let n = x.len() as f64;\n    let avg = mean(x);\n    let sq_diffs: f64 = x\n        .iter()\n        .map(|xi| (xi - avg).powi(2))\n        .sum();\n    sq_diffs / (n - 1.0)\n}\n\nfn main() {\n    let x = vec![2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0];\n    println!(\"Variance is: {:.2}\", variance(&x));\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Mapping over Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/iter-map.html#exercise-2",
    "href": "intro-to-rust-for-r-devs/iter-map.html#exercise-2",
    "title": "13  Mapping over Iterators",
    "section": "Exercise 2",
    "text": "Exercise 2\nCreate a function standardize() to perform z-score standardization on a vector of f64.\n\\[\nz_i = \\frac{x_i - \\mu}{\\sigma}\n\\]\n\nUse .iter() and .map() to calculate mean and variance.\nUse .into_iter(), .map(), and .collect() to build the standardized vector.\nReturn a new Vec&lt;f64&gt; of standardized values.\n\n\nSolution\n\n\nView solution\n\nfn standardize(x: &[f64]) -&gt; Vec&lt;f64&gt; {\n    let avg = mean(x);\n    let std_dev = variance(x).sqrt();\n    x.iter().map(|xi| (xi - avg) / std_dev).collect()\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let standardized = standardize(x);\n    println!(\"Standardized: {:?}\", standardized);\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Mapping over Iterators</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/structs.html",
    "href": "intro-to-rust-for-r-devs/structs.html",
    "title": "14  Defining Struct(ure)s",
    "section": "",
    "text": "Exercise\nYou can define a type as being a collection of other types by using the struct keyword.\nBy convention structs are named using PascalCase, as opposed to fns which are named using snake_case convention.\nAdding behavior to struct is possible through attributes:\nThe Debug trait allows debug printing of the type Point via dbg! or println!(\"{p:?}).\nFields of a struct can be accessed directly, or by reference. If a field is accessed by reference, the struct cannot be moved.\nUnpacking a struct entirely is possible",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Defining Struct(ure)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/structs.html#exercise",
    "href": "intro-to-rust-for-r-devs/structs.html#exercise",
    "title": "14  Defining Struct(ure)s",
    "section": "",
    "text": "Define a struct called Point which has two fields x, and y\nCreate a new Point struct\nDestructure the point",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Defining Struct(ure)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/struct-methods.html",
    "href": "intro-to-rust-for-r-devs/struct-methods.html",
    "title": "15  Struct Methods",
    "section": "",
    "text": "Exercise",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Struct Methods</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/struct-methods.html#exercise",
    "href": "intro-to-rust-for-r-devs/struct-methods.html#exercise",
    "title": "15  Struct Methods",
    "section": "",
    "text": "Define a new method\n\nimpl Struct {\n  fn new(x: f64, y: f64) -&gt; Self {\n    Self { x, y }\n  }\n}\n\ndefine a distance method that calculates the euclidean distance between a point and a reference to another\n\nimpl Point {\n    fn euclidean_distance(&self, destination: &Self) -&gt; f64 {\n        ((self.x - destination.x).powi(2) + (self.y - destination.y).powi(2)).sqrt()\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Struct Methods</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/struct-methods.html#bonus-exercise-2",
    "href": "intro-to-rust-for-r-devs/struct-methods.html#bonus-exercise-2",
    "title": "15  Struct Methods",
    "section": "Bonus: Exercise 2",
    "text": "Bonus: Exercise 2\nHaversine distance is a fast way of calculating distances on a sphere. It is not the most accurate method for all cases, but it’s good enough for many common applications like calculating distances between cities!\nIt is defined by the following equation:\nThe Haversine formula computes the distance between two points on a sphere given their longitudes and latitudes.\n\\[a = \\sin^2\\left(\\frac{\\Delta\\phi}{2}\\right) + \\cos\\phi_1 \\cdot \\cos\\phi_2 \\cdot \\sin^2\\left(\\frac{\\Delta\\lambda}{2}\\right)\\]\n\\[c = 2 \\cdot \\text{atan2}(\\sqrt{a}, \\sqrt{1-a})\\]\n\\[d = R \\cdot c\\]\nWhere:\n\n\\(\\phi\\) represents latitude (in radians) (use .to_radians())\n\\(\\lambda\\) represents longitude (in radians) (use .to_radians())\n\\(R\\) is the Earth’s radius (you can use 6_371_008_7714f64 meters as a mean radius)\n\\(\\Delta\\phi\\) is the difference in latitude between the two points (\\(\\phi_2 - \\phi_1\\))\n\\(\\Delta\\lambda\\) is the difference in longitude between the two points (\\(\\lambda_2 - \\lambda_1\\))\n\\(\\text{atan2}(y, x)\\) is the arctangent of \\(y/x\\), using the signs of both arguments to determine the correct quadrant.\n\nHints for Implementation:\n\nRemember to convert your latitude and longitude values from degrees to radians using the .to_radians() method on f64.\nThe c part of the formula, \\(2 \\cdot \\text{atan2}(\\sqrt{a}, \\sqrt{1-a})\\), can also be implemented using 2 * a.sqrt().asin() in Rust, which is a common simplification when a is within the valid domain for asin.\n\n\nSolution\nimpl Point {\n    fn haversine_distance(&self, destination: &Self) -&gt; f64 {\n        let radius = 6_371_008.7714; // Earth's mean radius in meters\n        let theta1 = self.y.to_radians(); // Latitude of point 1\n        let theta2 = destination.y.to_radians(); // Latitude of point 2\n        let delta_theta = (destination.y - self.y).to_radians(); // Delta Latitude\n        let delta_lambda = (destination.x - self.x).to_radians(); // Delta Longitude\n\n        let a = (delta_theta / 2f64).sin().powi(2)\n            + theta1.cos() * theta2.cos() * (delta_lambda / 2f64).sin().powi(2);\n\n        2f64 * a.sqrt().asin() * radius\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Struct Methods</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/enums.html",
    "href": "intro-to-rust-for-r-devs/enums.html",
    "title": "16  Enum(eration)s",
    "section": "",
    "text": "Enums in R",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Enum(eration)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/enums.html#enums-in-r",
    "href": "intro-to-rust-for-r-devs/enums.html#enums-in-r",
    "title": "16  Enum(eration)s",
    "section": "",
    "text": "for example the R function stats::cor() has the argument method = c(\"pearson\", \"kendall\", \"spearman\").\n\nmethod can only be pearson kendall or spearman otherwise an error happens\n\nthis is an informal way of specifying an enumeration\n\ni’ve wrtten about this in more detail in R which may be interesting for y’all\n\nhttps://josiahparry.com/posts/2023-11-10-enums-in-r/\n\n\n\n\nExample:\nwe can define an enum called Shape\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Enum(eration)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/enums.html#variant-specific-behavior",
    "href": "intro-to-rust-for-r-devs/enums.html#variant-specific-behavior",
    "title": "16  Enum(eration)s",
    "section": "Variant-specific behavior",
    "text": "Variant-specific behavior\n\nchoose a variant by EnumName::Variant This means that Shape can take on only one of those 4 variants\nseems kind of confusing at first, how do you actually use this?\nwe perform pattern matching on the enum and perform some action based on the variant\nuse the keyword match to perform an action based on the value\nwe list each variant and define the action that happens using format Enum::Variant =&gt; action\nnote the “fat arrow”\n\nmatch my_shape {\n    Shape::Triangle =&gt; todo!(),\n    Shape::Rectangle =&gt; todo!(),\n    Shape::Pentagon =&gt; todo!(),\n    Shape::Hexagon =&gt; todo!(),\n}\n\n\n\n\n\n\ntodo!() is a placeholder that can be used to make the compiler happy\n\n\n\n\nExample\n\nwe print the number of vertices for each shape\n\nlet my_shape = Shape::Triangle;\n\nmatch my_shape {\n    Shape::Triangle =&gt; println!(\"A triangle has 3 vertices\"),\n    Shape::Rectangle =&gt; println!(\"A rectangle has 4 vertices\"),\n    Shape::Pentagon =&gt; println!(\"A pentagon has 5 vertices\"),\n    Shape::Hexagon =&gt; println!(\"A hexagon has 6 vertices\"),\n}\n\nsometimes we only want to customize behavior on only a subset of variants\nwe can use a catch all in the match statement _ =&gt; use the underscore to signify “everything else”\n\nmatch my_shape {\n    Shape::Hexagon =&gt; println!(\"Hexagons are the bestagons);\n    _ =&gt; println!(\"Every other polygon is mid\");\n}\nEnums can have methods too just like a struct using impl keyword\nimpl Shape {\n    fn is_bestagon(&self) -&gt; bool {\n        match self {\n            Self::Hexagon =&gt; true,\n            _ =&gt; false\n        }\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Enum(eration)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/enums.html#exercise-1",
    "href": "intro-to-rust-for-r-devs/enums.html#exercise-1",
    "title": "16  Enum(eration)s",
    "section": "Exercise 1",
    "text": "Exercise 1\n\nrecreate the shape enum\ncreate a method called n_vertices() which returns a usize\ncreate two different variants of the Shape enum and print their number of vertices",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Enum(eration)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/enums.html#exercise-2",
    "href": "intro-to-rust-for-r-devs/enums.html#exercise-2",
    "title": "16  Enum(eration)s",
    "section": "Exercise 2",
    "text": "Exercise 2\n\nCreate an enum called Measure with two variants Euclidean and Haversine\nCreate a new method distance() for our point struct that takes 3 arguments and returns an f64\n\na reference to self\na reference to another point\na reference to a Measure enum\n\nWhen the variant is Euclidean use the euclidean_distance() method\nWhen the variant is Haversine use the haversine_distance() method\n\nenum Measure {\n    Euclidean,\n    Haversine,\n}\n\nimpl Point {\n    // Demonstrates using pattern matching an enum\n    fn distance(&self, destination: &Self, measure: &Measure) -&gt; f64 {\n        match measure {\n            Measure::Euclidean =&gt; self.euclidean_distance(destination),\n            Measure::Haversine =&gt; self.haversine_distance(destination),\n        }\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Enum(eration)s</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/options.html",
    "href": "intro-to-rust-for-r-devs/options.html",
    "title": "17  Some() or None?",
    "section": "",
    "text": "Danger! .unwrap() & .expect()\nOption is defined as:\nwe can match on these. When we have a some value we can use the inner value when we dont we can perform some fallback operation",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>`Some()` or `None`?</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/options.html#danger-.unwrap-.expect",
    "href": "intro-to-rust-for-r-devs/options.html#danger-.unwrap-.expect",
    "title": "17  Some() or None?",
    "section": "",
    "text": "sometimes dealing with options is a headache, particularly when we’re in the early stages of developing\nto get the inner value of an Option&lt;T&gt; without checking we can use .unwrap() or .expect()\nthese both give you the inner value. If the value is not found then the program panics.\n\nthis is very bad\n\nTODO panic screenshot\n.expect() takes a message so that when a panic is encountered the message is more informative.",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>`Some()` or `None`?</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/options.html#exercise",
    "href": "intro-to-rust-for-r-devs/options.html#exercise",
    "title": "17  Some() or None?",
    "section": "Exercise",
    "text": "Exercise\n\nmodify the distance() method to take an Option&lt;Measure&gt;\nwhen None use euclidean distance, otherwise use the provided distance measure\n\n\n\nThe exercise does not involve .unwrap() because it’s a bad habbit. Let’s try and form good habbits from the outset if possible.\nimpl Point {\n    fn distance(&self, destination: &Self, measure: Option&lt;&Measure&gt;) -&gt; f64 {\n        match measure {\n            Some(m) =&gt; match m {\n                Measure::Euclidean =&gt; self.euclidean_distance(destination),\n                Measure::Haversine =&gt; self.haversine_distance(destination),\n            },\n            None =&gt; self.euclidean_distance(destination),\n        }\n    }\n}",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>`Some()` or `None`?</span>"
    ]
  },
  {
    "objectID": "intro-to-rust-for-r-devs/parallelize.html",
    "href": "intro-to-rust-for-r-devs/parallelize.html",
    "title": "18  Parallelizing",
    "section": "",
    "text": "TODO: before this we do combining iterators with .zip() and then go over destructuring into tuples there\n\nthis is a stretch exercise\nBrief intro to rayon\npar_iter()\ninto_par_iter()\nwith_min_len()\nObjective is to calculate the pairwise distances between two vectors of points super fast\nwe want to use .zip() to combine the two vectors\nthis would require using rand to create a vector of random numbers",
    "crumbs": [
      "Intro to Rust for R Developers",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Parallelizing</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html",
    "href": "building-rust-based-r-pkgs/index.html",
    "title": "Building Rust based R Packages",
    "section": "",
    "text": "Objective\nIn this workshop we will create a Rust-based R package to perform geohashing using extendr.\nThe first few sections of the workshop may be a litte “lesson” intensive and the latter portion light on it.",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#objective",
    "href": "building-rust-based-r-pkgs/index.html#objective",
    "title": "Building Rust based R Packages",
    "section": "",
    "text": "Learn how to create Rust based R packages using extendr\nBegin to feel comfortable working with data between R & Rust\nCreate an R package to perform geohashing based on the Rust crate called geohash",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#general-overview",
    "href": "building-rust-based-r-pkgs/index.html#general-overview",
    "title": "Building Rust based R Packages",
    "section": "General Overview",
    "text": "General Overview\n\nWhat is FFI\nWhat is extendr\n\nwebR support\n\nR’s C API\nextendr-ffi & extendr-api",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#what-is-a-geohash",
    "href": "building-rust-based-r-pkgs/index.html#what-is-a-geohash",
    "title": "Building Rust based R Packages",
    "section": "What is a geohash?",
    "text": "What is a geohash?\n\nnot everyone is a geospatial nerd but i am\ni have 2 videos on this exact concept\na third video that goes through making this package that inspired this workshop\nSuper quick review of what a geohash is",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#hello-world",
    "href": "building-rust-based-r-pkgs/index.html#hello-world",
    "title": "Building Rust based R Packages",
    "section": "Hello, World!",
    "text": "Hello, World!\n\nCreating a new package usethis::create_package(rstudio = FALSE)\nAdd extendr rextendr::use_extendr()\npackage structure\n\nprevious workshop used a binary crate, we will be building a library crate\n\nrextendr::document()\ndevtools::load_all()\nhello_world()\nreview the contents\n#[extendr] attribute macro\nrprintln!()",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#rextendr-dx",
    "href": "building-rust-based-r-pkgs/index.html#rextendr-dx",
    "title": "Building Rust based R Packages",
    "section": "rextendr DX",
    "text": "rextendr DX\n\nshow the VS Code settings\nrunning cargo check",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#adding-dependencies",
    "href": "building-rust-based-r-pkgs/index.html#adding-dependencies",
    "title": "Building Rust based R Packages",
    "section": "Adding dependencies",
    "text": "Adding dependencies\n\nadd geohash dependency\nrextendr::use_crate()\nimport structs and functions\nimport Coord and encode()",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#a-new-r-function",
    "href": "building-rust-based-r-pkgs/index.html#a-new-r-function",
    "title": "Building Rust based R Packages",
    "section": "A new R function",
    "text": "A new R function\n\ncreate a basic function gh_encode() that takes an x: f64 and a y: f64 value and prints the coordinate\nnext exercise add 3rd argument for length which is [1:12] it’s usize",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#throwing-r-errors",
    "href": "building-rust-based-r-pkgs/index.html#throwing-r-errors",
    "title": "Building Rust based R Packages",
    "section": "Throwing R errors",
    "text": "Throwing R errors\n\nlet’s add validation with throw_r_error()\ncheck that the goehash length is appropriate range\nif not, throw and error",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#calling-rust-from-r",
    "href": "building-rust-based-r-pkgs/index.html#calling-rust-from-r",
    "title": "Building Rust based R Packages",
    "section": "Calling Rust From R",
    "text": "Calling Rust From R\n\nadd #[extendr] macro to the function\n\nthis does magic behind the hood to make it callable from R\n\nthe function must be added to extendr_module! {} for it to be available\nrun rextendr::document() for the new changes to take place\ndevtools::load_all() to make the function available",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#encoding-a-geohash",
    "href": "building-rust-based-r-pkgs/index.html#encoding-a-geohash",
    "title": "Building Rust based R Packages",
    "section": "Encoding a geohash",
    "text": "Encoding a geohash\n\nlets finish up our first function which will geohash a single coordinate by calling encode()\nencode() returns a Result&lt;String&gt;\na Result&lt;&gt; is a special type of Option&lt;&gt;\nwe will talk about handling errors gracefully in R later when we cover NA handling\nfor now we will .unwrap() the result right away\nadd the return type as String\n\nextendr will handle converting this into a character vector",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#vectorize-geohash-encoding",
    "href": "building-rust-based-r-pkgs/index.html#vectorize-geohash-encoding",
    "title": "Building Rust based R Packages",
    "section": "Vectorize geohash encoding",
    "text": "Vectorize geohash encoding\n\nmodify gh_encode() to take a Vec&lt;f64&gt; for both x and y\nWe will iterate through these together\nreview .zip() to merge iterators\nfor each element in the iterator we encode the geohash\ncollect to strings\nrextendr::document()\ndevtools::load_all()\n\ntest in R\nx &lt;- rnorm(100, -180, 180)\ny &lt;- rnorm(100, -90, 90)\ngh_len &lt;- 7\n\ngh_encode(x, y, gh_len)\n\nWhat about handling errors and NAs?\nGonna need to address type mapping first",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#type-mapping",
    "href": "building-rust-based-r-pkgs/index.html#type-mapping",
    "title": "Building Rust based R Packages",
    "section": "Type Mapping",
    "text": "Type Mapping\n\nvecs are fine for basic stuff.\nR types are more complex and have support for NULL and NA values\nScalar types\nVector types\nNULL in R\nRobj\nRust has the unit type (). We can tu",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#rs-type-system",
    "href": "building-rust-based-r-pkgs/index.html#rs-type-system",
    "title": "Building Rust based R Packages",
    "section": "R’s type system",
    "text": "R’s type system\n\nEverything is an SEXP\nBriefly discuss representations\nI thought really hard on whether or not to discuss this. Initially i thought i wouldnt, but i think it is actually really helpful to understand the fundamental data structures in R. It helps make the mental leaps much easier.\nSo we’re going to spend a few minutes discussing internal representations in R",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#robj-sexp",
    "href": "building-rust-based-r-pkgs/index.html#robj-sexp",
    "title": "Building Rust based R Packages",
    "section": "Robj & SEXP",
    "text": "Robj & SEXP\n\nin extendr, everything can be represented as an Robj\nRobj is an opaque type: we do not know what type it is, we just know its an Robj\na helpful catch-all\nwe can turn any extendr type into an Robj using the .into_robj() method",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#scalars",
    "href": "building-rust-based-r-pkgs/index.html#scalars",
    "title": "Building Rust based R Packages",
    "section": "Scalars",
    "text": "Scalars\n\nNA aware types that correspond to R’s type system\nevery scalar has na() method\n\n\nDoubles\n\ninternally represented by f64\naccess the inner f64 value using .inner()\nConvert f64 to an Rfloat using Rfloat::from(x)",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#strings",
    "href": "building-rust-based-r-pkgs/index.html#strings",
    "title": "Building Rust based R Packages",
    "section": "Strings",
    "text": "Strings\n\nA bit of a nightmare\nCreate Rstr from a String in Rust using Rstr::from(x)",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#using-extendr-types",
    "href": "building-rust-based-r-pkgs/index.html#using-extendr-types",
    "title": "Building Rust based R Packages",
    "section": "Using extendr types",
    "text": "Using extendr types\n\nrewrite gh_encode() to use Doubles and Strings\nwe can leave length as usize for now as it will always be scalar.\nto access the inner value of an Rfloat use .inner()",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#error-handling-in-rust",
    "href": "building-rust-based-r-pkgs/index.html#error-handling-in-rust",
    "title": "Building Rust based R Packages",
    "section": "Error handling in Rust",
    "text": "Error handling in Rust\n\n“And I think Result can be explained fairly quickly in the following way: Rust does not have exceptions. Errors are data. If a function is falliable, it returns Result, which is a fork between the successful value, and the error-as-data. We may ignore the error-branch entirely with .unwrap.” -Mossa\n\n\nHandle errors gracefully on the R side by returning a NULL or NA value when it is appropriate\ndescribe Result&lt;&gt; which is an enum.\nlet’s match on the result from encode()\n\nwhen Ok(gh) use Rstr::from(gh)\nwhen Err(e) use Rstr::na() to record a missing value\n\nwhen we try to encode data that is not in long lat we will get an error—e.g. if its in meter that wont work\nfor the exercise feed some bad data to the function to see it return an NA",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#na-handling",
    "href": "building-rust-based-r-pkgs/index.html#na-handling",
    "title": "Building Rust based R Packages",
    "section": "NA handling",
    "text": "NA handling\n\nnow what about when the coordinates are NA?\nhow do we handle that?\nwe can check Rfloat::is_na()\n\nif either Rfloat::is_na() return Rstr::na()\nelse, do the geohash\n\ntest with NA values",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#geohash-neighbor",
    "href": "building-rust-based-r-pkgs/index.html#geohash-neighbor",
    "title": "Building Rust based R Packages",
    "section": "Geohash Neighbor",
    "text": "Geohash Neighbor\n\nA geohash is a square grid\neach location has up to 6 neighbors\nto find a specific neighbor we can use the neighbor() function\nthis function takes an enum for direction",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#enums-in-r",
    "href": "building-rust-based-r-pkgs/index.html#enums-in-r",
    "title": "Building Rust based R Packages",
    "section": "Enums in R",
    "text": "Enums in R\n\nfirst step, lets make a utility function to take a String and convert this to the enum\n\ngh_neighbor &lt;- function(gh, neighbor = c(\"N\",\"NE\",\"E\",\"SE\",\"S\",\"SW\",\"W\",\"NW\")) {\n  arg.match(neighbor)\n  # function body\n}",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#custom-enum-handling",
    "href": "building-rust-based-r-pkgs/index.html#custom-enum-handling",
    "title": "Building Rust based R Packages",
    "section": "Custom Enum handling",
    "text": "Custom Enum handling\n\nmatch statements can be used on strings too\nthere will be a catch all part of the match\nin the function\n\nfn as_direction(direction: String) -&gt; Direction {\n    match direction.to_lowercase().as_str() {\n        \"n\" =&gt; Direction:N,\n        \"ne\" =&gt; Direction:NE,\n        \"e\" =&gt; Direction:E,\n        \"se\" =&gt; Direction:SE,\n        \"s\" =&gt; Direction:S,\n        \"sw\" =&gt; Direction:SW,\n        \"w\" =&gt; Direction:W,\n        \"nw\" =&gt; Direction:NW,\n        _ =&gt; throw_r_error(\"Invalid geohash neighbor direction\")\n    }\n}",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#single-neighbor-function",
    "href": "building-rust-based-r-pkgs/index.html#single-neighbor-function",
    "title": "Building Rust based R Packages",
    "section": "Single Neighbor function",
    "text": "Single Neighbor function\nExercise\n\nCreate a function gh_decode()\nreturns Option&lt;String&gt;\ntakes 2 args:\n\ngeohash: String\ndirection: String\n\ncast the direction to the Direction enum\npass into the neighbor() function\nIf there is an error in the result, return None\nIf successful return Some(geohash)\ndocument and run the function in R to see the result\ntest with bad data",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#vectorize-the-neighbor-function",
    "href": "building-rust-based-r-pkgs/index.html#vectorize-the-neighbor-function",
    "title": "Building Rust based R Packages",
    "section": "Vectorize the neighbor function",
    "text": "Vectorize the neighbor function\n\nModify gh_decode() to take geohash: Strings\nReturns Strings\nUse .into_iter().map().collect::&lt;String&gt;() to return a vector of neighbors\nHandle NA values for geohash, return an Rstr::na()\nHandle errors return Rstr::na()\nOtherwise return Rstr::from()\nCollect into Strings",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#decoding-a-geohash",
    "href": "building-rust-based-r-pkgs/index.html#decoding-a-geohash",
    "title": "Building Rust based R Packages",
    "section": "Decoding a geohash",
    "text": "Decoding a geohash\n\na geohash isn’t a coordinate, but rather a bounding box\nthe decode() function decodes into a center point and error in two directions\nThe signature is pub fn decode(hash_str: &str) -&gt; Result&lt;(Coord, f64, f64), GeohashError&gt;\nthe Coord is a “generic” struct it has fields x & y and the x & y error\nmost natural way to work with this in R would be to create a data frame\nHow can we create a data frame in extendr?\nthere’s a few ways. We’re going to go ahead and create one from scratch",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#what-is-there-to-a-data.frame",
    "href": "building-rust-based-r-pkgs/index.html#what-is-there-to-a-data.frame",
    "title": "Building Rust based R Packages",
    "section": "What is there to a data.frame?",
    "text": "What is there to a data.frame?\n\ndata.frames are just lists masquerading as a rectangle\n\n\nnamed vectors\nstructs are record based not column based (this is kinda the whole thing about apache arrow)\nHow can we handle this?\nusing an iterator isn’t the most logical for this. Instead, we can use a for loop\nwe can allocate our own vectors and then fill them in a for loop",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#tuples",
    "href": "building-rust-based-r-pkgs/index.html#tuples",
    "title": "Building Rust based R Packages",
    "section": "Tuples",
    "text": "Tuples\n\nThe decode function returns a tuple which we haven’t yet covered.\ntuples are the heterogenous collection type in Rust\nif you’ve used tuples in python they’re pretty much the same\nelements in the tuple are not named\ngenerally good for holding only a handful of items, otherwise just define a struct\nwe access elements from the tuple via .0, .1, .2\nWe can perform destructuring assignment of tuples too which will be handy",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#creating-vectors",
    "href": "building-rust-based-r-pkgs/index.html#creating-vectors",
    "title": "Building Rust based R Packages",
    "section": "Creating vectors",
    "text": "Creating vectors\n\nDoubles, Strings, and Logicals are wrappers around R types\nWe can collect into these types or we can create them\nWe can allocate empty vectors using associated method Doubles::new(usize)\n\nBut filling these is actually somewhat slow due to the FFI boundary\n\nAssociated method Doubles::from_values() to collect values into a vector\n\nStore Vec&lt;Rfloat&gt;\nCollect from the vector",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#creating-data.frames",
    "href": "building-rust-based-r-pkgs/index.html#creating-data.frames",
    "title": "Building Rust based R Packages",
    "section": "Creating data.frames",
    "text": "Creating data.frames\n\nThere are two primary ways of creating data.frames in extendr\nI recommend using the data_frame!() macro\nthis returns an untyped R object: Robj\n\n\n\nExercise\n\ncreate 4 empty vectors to store:\n\nx, y, x_error, y_error\n\nCreate a for loop on the geohash note you have to call .into_iter() explicitly\n\n\nfn gh_decode(geohash: Strings) -&gt; Robj {\n    let mut x_res = Vec::new();\n    let mut y_res = Vec::new();\n    let mut x_error = Vec::new();\n    let mut y_error = Vec::new();\n\n    for gh in geohash.into_iter() {\n        let resi = decode(gh);\n        match resi {\n            Ok((Coord { x, y }, xe, ye)) =&gt; {\n                x_res.push(Rfloat::from(x));\n                y_res.push(Rfloat::from(y));\n                x_error.push(Rfloat::from(xe));\n                y_error.push(Rfloat::from(ye));\n            }\n            Err(_) =&gt; {\n                x_res.push(Rfloat::na());\n                y_res.push(Rfloat::na());\n                x_error.push(Rfloat::na());\n                y_error.push(Rfloat::na());\n            }\n        }\n    }\n\n    data_frame!(\n        x = Doubles::from_values(x_res),\n        y = Doubles::from_values(y_res),\n        x_error = Doubles::from_values(x_error),\n        y_error = Doubles::from_values(y_error)\n    )\n}",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#geohash-neighbors",
    "href": "building-rust-based-r-pkgs/index.html#geohash-neighbors",
    "title": "Building Rust based R Packages",
    "section": "Geohash Neighbors",
    "text": "Geohash Neighbors\n\nWe already made a vectorized functioon to find neighbors in a single direction.\nbut there is also a function neighbors() that returns a struct Neighbors that has the geohash for all neighbors\nThis would be a nice function to have access to in R\nhow should we do this?\nwe can take a similar approach we did for gh_decode()\nBut that’s a lot of boiler plate!\nThere’s another approach to this\nIntoDataFrameRow trait which we can derive",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#traits",
    "href": "building-rust-based-r-pkgs/index.html#traits",
    "title": "Building Rust based R Packages",
    "section": "Traits",
    "text": "Traits\n\nin the previous workhop we used the #[derive()] attribute to be able to have debug printing\nwhat is a trait?\nare similar to object oriented programming\nthey define behaviors that a type can perform\nthey are how we share behavior across rust libraries\nthey’re common methods that can be implemented for any type you own\nmany traits can be “derived” this means you can get them on your type “for free” without doing work",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#deriving-intodataframerow-for-neighbors",
    "href": "building-rust-based-r-pkgs/index.html#deriving-intodataframerow-for-neighbors",
    "title": "Building Rust based R Packages",
    "section": "Deriving IntoDataFrameRow for Neighbors",
    "text": "Deriving IntoDataFrameRow for Neighbors\n\nlets try deriving it\nlol oops! That sucks! we cant implement traits for types we don’t own.\nthis is called the “orphan rule”",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#work-around-create-your-own-struct",
    "href": "building-rust-based-r-pkgs/index.html#work-around-create-your-own-struct",
    "title": "Building Rust based R Packages",
    "section": "Work-around: create your own struct",
    "text": "Work-around: create your own struct\n\none way to handle this is to create your own struct that you can implement traits on\nwe can create our own struct GHNeighbors\nSince we own GHNeighbors we can derive IntoDataFrameRow for it\nbut how do we go from Neighbors to GHNeighbors?\nwe can implement a trait From",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#from-trait",
    "href": "building-rust-based-r-pkgs/index.html#from-trait",
    "title": "Building Rust based R Packages",
    "section": "From trait",
    "text": "From trait\n\npart of the standard library\nthis provides a 0-cost abstraction\nlets us go from T to U without incurring any runtime cost\nuse the impl keyword to implement a trait\nimpl Trait for OurType\nThe From trait requires us to specify a type:\nimpl From&lt;ForeignType&gt; for OurType\n\n\nExample\nimpl From&lt;Coord&lt;f64&gt;&gt; for Point {\n    fn from(value: Coord&lt;f64&gt;) -&gt; Self {\n        Point {\n            x: Rfloat::from(value.x),\n            y: Rfloat::from(value.y),\n        }\n    }\n}\nThis lets us do something like:\nlet coord = Coord::zero();\nlet p = Point::from(coord);\nPro-tip if you write:\nimpl From&lt;T&gt; for U {\n    // have cursor here and type `cmd + .`\n}\n\nThis opens the “Quick fix”\npress “implement missing members” which fills the template:\n\nimpl From&lt;T&gt; for U {\n    fn from(value: T) -&gt; Self {\n        // construct Self / U struct here\n        todo!()\n    }\n}",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#default-trait",
    "href": "building-rust-based-r-pkgs/index.html#default-trait",
    "title": "Building Rust based R Packages",
    "section": "Default trait",
    "text": "Default trait\n\nwhat happens when we run into an error finding the neighbors?\nwe want to be able to return a row of NAs\nrather than constructing the whole thing from struct each time we want to use a full row of NA\nwe can actually instead, implement a default value\nnote often the default trait can be derived\n\n\nExample\nimpl Default for Point {\n    fn default() -&gt; Self {\n        Self {\n            x: Rfloat::na(),\n            y: Rfloat::na(),\n        }\n    }\n}\n\n\nExercise\nImplement the Default trait for GHNeighbors\nimpl Default for GHNeighbors {\n    fn default() -&gt; Self {\n        Self {\n            sw: Rstr::na(),\n            s: Rstr::na(),\n            se: Rstr::na(),\n            w: Rstr::na(),\n            e: Rstr::na(),\n            nw: Rstr::na(),\n            n: Rstr::na(),\n            ne: Rstr::na(),\n        }\n    }\n}\nThis lets us write GHNeighbors::default()",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#put-it-all-together",
    "href": "building-rust-based-r-pkgs/index.html#put-it-all-together",
    "title": "Building Rust based R Packages",
    "section": "Put it all together",
    "text": "Put it all together\n\nlets combine the use of our implementations of From, Default, and IntoDataFrameRow row to write gh_neighbors()\n\n\nExercise\n#[extendr]\nfn gh_neighbors(geohashes: Strings) -&gt; Robj {\n    let all_rows = geohashes\n        .into_iter()\n        .map(|gh| match neighbors(gh.as_str()) {\n            Ok(nbs) =&gt; GHNeighbors::from(nbs),\n            Err(_) =&gt; GHNeighbors::default(),\n        })\n        .collect::&lt;Vec&lt;_&gt;&gt;();\n\n    all_rows.into_dataframe().unwrap().into_robj()\n}",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#you-help-me-choose-what-to-do-next",
    "href": "building-rust-based-r-pkgs/index.html#you-help-me-choose-what-to-do-next",
    "title": "Building Rust based R Packages",
    "section": "You help me choose what to do next",
    "text": "You help me choose what to do next\n\nQ&A?\nThe last function but independently?\nCRAN compatibility?",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#all-on-your-own-now",
    "href": "building-rust-based-r-pkgs/index.html#all-on-your-own-now",
    "title": "Building Rust based R Packages",
    "section": "All on your own now",
    "text": "All on your own now\n\nthe decode_bbox() function",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#cran-compatibility",
    "href": "building-rust-based-r-pkgs/index.html#cran-compatibility",
    "title": "Building Rust based R Packages",
    "section": "CRAN Compatibility",
    "text": "CRAN Compatibility\n\nvendoring\nMSRV",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#using-github-actions",
    "href": "building-rust-based-r-pkgs/index.html#using-github-actions",
    "title": "Building Rust based R Packages",
    "section": "Using GitHub Actions",
    "text": "Using GitHub Actions\n\nR CMD check\nCRAN checks",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/index.html#thank-you",
    "href": "building-rust-based-r-pkgs/index.html#thank-you",
    "title": "Building Rust based R Packages",
    "section": "Thank you",
    "text": "Thank you\n\nJoin our Discord",
    "crumbs": [
      "Building Rust based R Packages"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/objective.html",
    "href": "building-rust-based-r-pkgs/objective.html",
    "title": "21  Workshop Scope",
    "section": "",
    "text": "What is geohashing?\nThere’s no better way to learn than by doing.\nIn this workhop we will learn how to use extendr and create Rust-powered R package by creating a new package called {geohash}. The {geohash} R package will provide R bindings to the geohash crate.\nThroughout the workshop we will touch on:\nAs much as this is about Rust, we are also working within the confines of R and thus, he two are inextricably linked.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Workshop Scope</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr-dx.html",
    "href": "building-rust-based-r-pkgs/extendr-dx.html",
    "title": "25  Developer Experience",
    "section": "",
    "text": "Objective\n\n\n\n\n\n\n{\n  \"rust-analyzer.linkedProjects\": [\n    \"${workspaceFolder}/src/rust/Cargo.toml\"\n  ],\n  \"files.associations\": {\n    \"Makevars.in\": \"makefile\",\n    \"Makevars.win\": \"makefile\",\n    \"configure\": \"shellscript\",\n    \"configure.win\": \"shellscript\",\n    \"cleanup\": \"shellscript\",\n    \"cleanup.win\": \"shellscript\"\n  }\n}\n\nsettings.json\nrunning cargo check",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Developer Experience</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/encode.html",
    "href": "building-rust-based-r-pkgs/encode.html",
    "title": "29  Encoding a geohash",
    "section": "",
    "text": "results\n.unwrap()\n.expect()\n\n\n\nView solution",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Encoding a geohash</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/vectorize.html",
    "href": "building-rust-based-r-pkgs/vectorize.html",
    "title": "30  Vectorizing",
    "section": "",
    "text": ".zip() iterator",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Vectorizing</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/r-type-system.html",
    "href": "building-rust-based-r-pkgs/r-type-system.html",
    "title": "31  R’s Type System",
    "section": "",
    "text": "everythign is an sexp",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>R's Type System</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/using-extendr-types.html",
    "href": "building-rust-based-r-pkgs/using-extendr-types.html",
    "title": "33  Using extendr types",
    "section": "",
    "text": "Wrappers to SEXPs\ncloning is inexpensive, just creates another reference to the pointer",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Using extendr types</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/ffi.html",
    "href": "building-rust-based-r-pkgs/ffi.html",
    "title": "20  Foreign Function Interfaces (FFI)",
    "section": "",
    "text": "R’s C API\nForeign function interfaces (FFI) are mechanisms by which other (foreign) languages can be used in our programming langauge of choice. They are typically used to call compiled languages (like C / Rust) from an interpretted langauge (R).\nMuch of R’s success and power comes from a robust FFI tooling ecosystem. Some of the more prominent FFI libraries are:\nMost langauges have the ability to interact with C and C-types. R is written in C and exposes a C API. Rust is able to work with C and represent C types. This is where extendr comes in.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Foreign Function Interfaces (FFI)</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr.html",
    "href": "building-rust-based-r-pkgs/extendr.html",
    "title": "21  What is extendr?",
    "section": "",
    "text": "extendr-ffi\nextendr is a project that focuses on extending R with Rust. It is comprised of:\nextendr-ffi defines the types and functions in R’s C API using Rust functions and types. As R’s C API changes, extendr-ffi is responsible for ensuring that packages are backwards compatible.\nFortunately, we will never have to touch this layer. Everything is built on top of this crate.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>What is extendr?</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr.html#extendr-ffi",
    "href": "building-rust-based-r-pkgs/extendr.html#extendr-ffi",
    "title": "21  What is extendr?",
    "section": "",
    "text": "extendr-ffi is a crate that does the translation between R and Rust.\nR has many functions and types that are defined in C\nextendr-ffi provides Rust-compatible type definitions for the low-level C API\nwe will never have to touch this\nbut everything is built upon this layer",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>What is extendr?</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr.html#extendr-api",
    "href": "building-rust-based-r-pkgs/extendr.html#extendr-api",
    "title": "21  What is extendr?",
    "section": "extendr-api",
    "text": "extendr-api\nextendr-api is the high-level crate that is built upon extendr-ffi. It makes working with R types such as vectors feel fairly natural from a Rust perspective. It handles the oddities of garbage collection and everything else related to the FFI boundary.\nWe will spend the rest of the workshop using the extendr-api crate.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>What is extendr?</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr.html#extendr-engine",
    "href": "building-rust-based-r-pkgs/extendr.html#extendr-engine",
    "title": "21  What is extendr?",
    "section": "extendr-engine",
    "text": "extendr-engine\nThe extendr-engine is focused on the opposite direction—calling R from Rust. It enables us to start an R process inside of Rust as well as execute R code in that R process. It can be used in creating Rust-based CLI tools that call R or whatever else your imagination can think up.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>What is extendr?</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr.html#rextendr",
    "href": "building-rust-based-r-pkgs/extendr.html#rextendr",
    "title": "21  What is extendr?",
    "section": "{rextendr}",
    "text": "{rextendr}\nOn the R side exists {rextendr}. It is a {usethis}-like package for developing Rust-powered R packages.\nIt is primarily used to:\n\nscaffold R packages\ndocument Rust functions\nprepare packages for CRAN release\n\nIt also provide a knitr-engine which lets us include Rust in R Markdown documents.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>What is extendr?</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/objective.html#what-is-geohashing",
    "href": "building-rust-based-r-pkgs/objective.html#what-is-geohashing",
    "title": "21  Workshop Scope",
    "section": "",
    "text": "Geohashes are a way to encode a location on earth as a string of 1 - 12 characters.\nThe more shared characters there are between two geohashes, the closes in physical space the geohashes are.\nUsed to find approximately near locations.\nUsed frequently in databases and web development to quickly query results.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Workshop Scope</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/hello-world.html",
    "href": "building-rust-based-r-pkgs/hello-world.html",
    "title": "21  Hello, world!",
    "section": "",
    "text": "Developer functions\nWe’re now ready to create our R package.\nTo develop a Rust-based R package, there are a few functions we need to familiarize ourselves with.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Hello, world!</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/hello-world.html#rextendr-developer-functions",
    "href": "building-rust-based-r-pkgs/hello-world.html#rextendr-developer-functions",
    "title": "22  Hello, world!",
    "section": "",
    "text": "rextendr::use_extendr() - create the Rust infrastructure\nrextendr::document() - document and update Rust function definitions",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Hello, world!</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/hello-world.html#developer-workflow",
    "href": "building-rust-based-r-pkgs/hello-world.html#developer-workflow",
    "title": "21  Hello, world!",
    "section": "Developer workflow",
    "text": "Developer workflow\nThe typical workflow for developing an extendr package involves:\n\nModify the Rust source code\nUpdate the bindings documentation using rextendr::document()\nLoad the package devtools::load_all()\nTest the R functions\nRepeat",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Hello, world!</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/hello-world.html#exercise",
    "href": "building-rust-based-r-pkgs/hello-world.html#exercise",
    "title": "21  Hello, world!",
    "section": "Exercise",
    "text": "Exercise\n\nCreate a new package called {geohash} using {usethis}\nInclude extendr in the new package by running rextendr::use_extendr()\nCompile the package by using rextendr::document()\nLoad the package using devtools::load_all()\nRun hello_world()\n\n\nSolution\n\n\nView solution\n\nusethis::create_package(\"geohash\")\n# in the newly created package\nlibrary(rextendr)\n\n# add extendr scaffolding\nuse_extendr()\n\n# compile and document the Rust functions\ndocument()\n\n# load the R package\ndevtools::load_all()\n\n# run the hello_world()!\nhello_world()",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Hello, world!</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/export-to-r.html",
    "href": "building-rust-based-r-pkgs/export-to-r.html",
    "title": "27  Calling Rust from R",
    "section": "",
    "text": "View solution",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Calling Rust from R</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/decode.html",
    "href": "building-rust-based-r-pkgs/decode.html",
    "title": "39  Decode a geohash",
    "section": "",
    "text": "View solution",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Decode a geohash</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/vectorize-neighbor.html",
    "href": "building-rust-based-r-pkgs/vectorize-neighbor.html",
    "title": "38  Vectorize gh_neighbor()",
    "section": "",
    "text": "View solution",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Vectorize `gh_neighbor()`</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/type-mapping-p1.html",
    "href": "building-rust-based-r-pkgs/type-mapping-p1.html",
    "title": "32  Type Mapping",
    "section": "",
    "text": "View solution",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Type Mapping</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/rust-deps.html",
    "href": "building-rust-based-r-pkgs/rust-deps.html",
    "title": "26  Adding dependencies",
    "section": "",
    "text": "View solution",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Adding dependencies</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/na-handling.html",
    "href": "building-rust-based-r-pkgs/na-handling.html",
    "title": "35  Handle NAs gracefully",
    "section": "",
    "text": "View solution",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Handle NAs gracefully</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr-structure.html",
    "href": "building-rust-based-r-pkgs/extendr-structure.html",
    "title": "24  Package structure",
    "section": "",
    "text": "Using compiled code\nThe basic structure of an extendr-based R package is like so:",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Package structure</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr-structure.html#using-compiled-code",
    "href": "building-rust-based-r-pkgs/extendr-structure.html#using-compiled-code",
    "title": "24  Package structure",
    "section": "",
    "text": "compiled code has to be placed in the src/ directory\n\n.\n├── Makevars\n├── Makevars.in\n├── Makevars.win.in\n└── rust\n    ├── Cargo.lock\n    ├── Cargo.toml\n    ├── src\n\ninside of src/ there is a directory called rust\n\nthis contains a rust library crate\nprevious workshop we create a binary crate—something that can be run right away\nlibraries are typically included into other libraries or binaries and compiled together\nin our case, we are building a shared object / dll that is linked to by R\n\nVarious Makevars files are used to compile the R package and link to the generated rust library that we develop.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Package structure</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/extendr-structure.html#rust-libraries",
    "href": "building-rust-based-r-pkgs/extendr-structure.html#rust-libraries",
    "title": "24  Package structure",
    "section": "Rust libraries",
    "text": "Rust libraries\ninside of rust/ is a Rust library crate. The primary difference is that instead of having a main.rs we have also a lib.rs.\nIn the library we do not have any entrypoint that gets executed. It is much like an R package. We define functions aand structs etc that are used by R package.",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Package structure</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/objective.html#the-r-package",
    "href": "building-rust-based-r-pkgs/objective.html#the-r-package",
    "title": "21  Workshop Scope",
    "section": "The R package",
    "text": "The R package\nThe R package we will create will help us:\n\nencode geohashes\ndecoded geohash to x & y plus error terms\ndecode geohash into a bounding box\nfind geohash neighbors",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Workshop Scope</span>"
    ]
  },
  {
    "objectID": "building-rust-based-r-pkgs/hello-world.html#developer-functions",
    "href": "building-rust-based-r-pkgs/hello-world.html#developer-functions",
    "title": "21  Hello, world!",
    "section": "",
    "text": "I don’t use RStudio anymore so I set create_package(rstudio = FALSE) to not have Rproj.user created.\n\nusethos::create_package() creates an R package\nrextendr::use_extendr() creates the Rust infrastructure\nrextendr::document() document and update Rust function definitions",
    "crumbs": [
      "Building Rust based R Packages",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Hello, world!</span>"
    ]
  }
]